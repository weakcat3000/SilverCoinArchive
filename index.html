<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sqkii Mapper</title>

  <!-- MapTiler SDK (MapLibre) -->
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.umd.min.js"></script>
  <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.css" rel="stylesheet" />

  <!-- Leaflet (OSM raster) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- togeojson + jszip -->
  <script src="https://unpkg.com/@tmcw/togeojson@4.7.0/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Supabase JS (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.5/dist/umd/supabase.min.js"></script>

  <!-- OGL (UMD) for Dark Veil -->
  <script src="https://cdn.jsdelivr.net/npm/ogl@0.0.104/dist/ogl.umd.js"></script>

  <!-- Preload button click sound for instant play -->
  <link rel="preload" href="button.mp3" as="audio" />

  <style>
    :root{
      --panel:#0f1115; --panel-2:#12151b; --muted:#98a2b3; --text:#e5e7eb;
      --accent:#60a5fa; --border:#1f2430; --bg:#0b0d11; --chip:#1c212e; --side:300px;
      --red:#ef4444; --green:#22c55e; --blue:#3b82f6;
    }

    /* ===== Slim dark scrollbars (Chrome/Edge/Safari) ===== */
    *::-webkit-scrollbar{
      width: 6px;              /* thinner */
      height: 6px;
    }
    *::-webkit-scrollbar-track{
      background: var(--bg);   /* dark track */
    }
    *::-webkit-scrollbar-thumb{
      background: var(--border);            /* muted thumb */
      border-radius: 8px;
      border: 2px solid transparent;        /* creates a little inset */
      background-clip: padding-box;
    }
    *::-webkit-scrollbar-thumb:hover{
      background: #2a3243;     /* slightly brighter on hover */
    }

    /* Slightly wider on the sidebar only when hovered (nice UX) */
    .sidebar::-webkit-scrollbar{ width: 6px; }
    .sidebar:hover::-webkit-scrollbar{ width: 10px; }

    /* ===== Firefox ===== */
    html, body, .sidebar, .grp-list, #layers{
      scrollbar-width: thin;                      /* slim */
      scrollbar-color: var(--border) var(--bg);   /* thumb / track */
    }

    /* Draw Circle inputs: 2 long rows */
    .draw-grid{
      display:grid;
      grid-template-columns: 1fr auto; /* wide input + small Add button */
      gap:8px;
    }
    .draw-grid #draw-coord{
      grid-column: 1 / -1; /* make lat,lng span full width on its own row */
    }

    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    .app{position:relative;display:grid;grid-template-columns: var(--side) 1fr;height:100vh;transition:grid-template-columns .28s ease;}
    .ui-reopen{position:absolute;left:10px;top:10px;z-index:1100;display:none;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    .app.ui-collapsed .ui-reopen{display:inline-block;}
    .sidebar{position:relative;background:var(--panel);border-right:1px solid var(--border);overflow:auto;width:var(--side);transition:width .28s ease;isolation:isolate;}
    .darkveil-canvas{
      position:absolute; inset:0;
      z-index:5;                 /* put above UI blocks so it's visible */
      pointer-events:none;
      opacity:.35;               /* subtle strength */
      mix-blend-mode:overlay;    /* try soft-light / multiply if you prefer */
      filter:saturate(1.05) contrast(1.06) brightness(.98);
    }
    .header{position:relative; z-index:1; padding:12px;border-bottom:1px solid var(--border);display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center}
    .project-title{font-weight:800;font-size:16px;display:flex;gap:8px;align-items:center}
    .toolbar{position:relative; z-index:1; display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;}	
    .header .toolbar{ margin-top:0; }
    .btn{background:var(--chip);border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-weight:600;cursor:pointer;color:var(--text);}
    .btn.small{padding:4px 8px;font-size:12px;}
    .hint{color:var(--muted);font-size:12px;}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .row-split{display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center}
    input[type="url"],select,input[type="text"],input[type="number"]{position:relative; z-index:1; width:100%;box-sizing:border-box;border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:var(--panel-2);color:var(--text);}
    #mapgl, #mapleaf{height:100%;width:100%;}
    .layers-empty{padding:14px; position:relative; z-index:1;}
    .layer{position:relative; z-index:1; border-bottom:1px solid var(--border);background:var(--panel-2);}
    .layer+.layer{margin-top:10px;border-radius:10px;overflow:hidden;}
    .layer-head{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:10px 12px;}
    .layer-head .title{font-weight:700;}
    .layer-head .actions{display:flex;gap:6px;flex-wrap:wrap;}
    .import-line{padding:8px 12px;background:#0e1420;border-top:1px solid var(--border);}
    .import-line .link{color:var(--accent);font-weight:600;cursor:pointer;}
    .feature{display:grid;grid-template-columns:auto 1fr auto auto;gap:8px;align-items:center;padding:8px 12px;border-top:1px solid var(--border);}
    .feature .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;cursor:pointer;}
    .group-bullet{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;border:1px solid #2a3243;background:#11161f;color:#fff;font-size:12px;font-weight:800;}
    .toggle{display:inline-grid;place-items:center;width:16px;height:16px;border:1px solid #2a3243;border-radius:4px;background:#0f141d;cursor:pointer;}
    .toggle.checked{background:#16a34a;border-color:#16a34a;}
    details.grp{position:relative; z-index:1; margin:10px 12px;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);}
    details.grp>summary{list-style:none;padding:10px 12px;cursor:pointer;font-weight:700;}
    details.grp>summary::-webkit-details-marker{display:none;}
    .grp-list{padding:8px 12px;display:grid;gap:6px;max-height:220px;overflow:auto;}
    .yt-portrait{width:240px;aspect-ratio:9/16;background:#000;border-radius:12px;overflow:hidden;margin:8px auto;}
    @media (min-width:480px){ .yt-portrait{ width:260px; } }
    .yt-portrait>iframe{width:100%;height:100%;display:block;border:0}
    .ui-hide{grid-column:3;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    a{color:var(--accent);}
    .maplibregl-popup-content{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .maplibregl-popup-tip{border-top-color:#0f1115 !important;border-bottom-color:#0f1115 !important;border-left-color:#0f1115 !important;border-right-color:#0f1115 !important;}
    .leaflet-popup-content-wrapper{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .leaflet-popup-tip{background:#0f1115;}
    .style-editor{position:fixed;z-index:1200;display:none;min-width:240px;max-width:280px;background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;padding:12px;box-shadow:0 12px 32px rgba(0,0,0,.45);}
    .style-editor h4{margin:0 0 8px 0;font-size:14px;}
    .style-row{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center;margin:8px 0;}
    .style-row input[type="color"],.style-row input[type="number"],.style-row input[type="range"]{width:100%;background:#12151b;border:1px solid #1f2430;color:#e5e7eb;border-radius:8px;padding:6px 8px;}
    .style-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:6px;}
    .style-actions .btn{padding:6px 10px;}
    .btn.danger{background:rgba(239,68,68,.1);border-color:#7f1d1d;color:#fecaca}

    /* Eye toggle button for feature visibility */
    .eye-btn{
      display:inline-grid; place-items:center;
      width:38px; height:30px; border:1px solid var(--border);
      border-radius:8px; background:var(--panel-2); cursor:pointer;
    }
    .eye-btn svg{ width:18px; height:18px; stroke:#e5e7eb; fill:none; stroke-width:2; }
    .eye-btn.off{ opacity:.6; }

    /* Smaller feature rows in the layer list */
    .feature { padding: 6px 12px; }              /* a bit tighter vertically */
    .feature .name { font-size: 13px; line-height: 1.25; }
    .group-bullet { width: 18px; height: 18px; font-size: 11px; } /* optional: smaller dot */

    /* Make the Edit button match Hide UI */
    /* Make the Edit toggle visually match Hide UI */
    #edit-toggle{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;          /* same as .ui-hide */
      padding: 6px 10px;            /* same as .ui-hide */
      font-weight: 700;             /* same as .ui-hide */
      box-shadow: 0 2px 14px rgba(0,0,0,.35); /* optional: match .ui-hide */
    }
    #edit-toggle.off{ opacity:.6; } /* your muted/off state */

    /* compact feature rows */
    .feature{grid-template-columns:14px 1fr auto auto;padding:2px 8px;gap:4px}
    .feature .name{font-size:11px;line-height:1.15}
    .group-bullet{width:14px;height:14px;font-size:9px}
    .btn.small{padding:1px 6px;font-size:11px;line-height:1.05}
    .eye-btn{width:30px;height:22px}
    .eye-btn svg{width:14px;height:14px}


    /* ---- Server Code Modal + blocking ---- */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;place-items:center;z-index:2000;}
    .modal.visible{display:grid;}
    .modal-card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;max-width:380px;width:92%;box-shadow:0 12px 40px rgba(0,0,0,.5);}
    .modal-card h3{margin:0 0 8px 0;font-size:16px}
    .modal-row{display:grid;grid-template-columns:1fr auto;gap:8px;margin-top:8px}
    .modal small{color:var(--muted)}
    .modal .err{color:#f87171;font-weight:700;margin-top:6px;display:none}
    .app.blocked-by-modal{pointer-events:none;}
    .modal, .modal *{pointer-events:auto;}

    /* layout for the Map style row */
    .mapstyle-row{
      position:relative; z-index:1;
      padding:12px;
      border-bottom:1px solid var(--border);
      display:grid;
      grid-template-columns: 1fr auto;
      gap:14px;
      align-items:start;
    }
    .mapstyle-right{ color:var(--muted); font-size:12px; text-align:right; line-height:1.35; max-width:240px; padding-top:2px; }
    .mapstyle-left .label{ color:var(--muted); font-size:12px; margin-bottom:4px; }

    /* Bigger white close button that sits just outside the popup corner */
    .maplibregl-popup-close-button{
      position:absolute; top:-8px; right:-8px; color:#fff !important; font-size:22px;
      width:28px; height:28px; line-height:28px; background:rgba(0,0,0,.55); border-radius:50%;
      border:none; box-shadow:0 2px 6px rgba(0,0,0,.35); text-shadow:none; opacity:1; z-index:2;
    }
    .maplibregl-popup-close-button:hover{ filter:brightness(1.15); }
    .leaflet-popup-close-button{
      position:absolute; top:-8px; right:-8px; color:#fff !important; font-size:22px;
      width:28px; height:28px; line-height:28px; background:rgba(0,0,0,.55); border-radius:50%;
      border:none; box-shadow:0 2px 6px rgba(0,0,0,.35); text-shadow:none; opacity:1; z-index:2;
    }
    .leaflet-popup-close-button:hover{ filter:brightness(1.15); }

    /* ---- Floating Sonar Button ---- */
    .sonar-btn{
      position:fixed;right:16px;bottom:16px;z-index:1500;width:64px;height:64px;border-radius:12px;background:#0e1420;
      border:1px solid var(--border);box-shadow:0 8px 24px rgba(0,0,0,.35);background-image:url('metal-sonar.png');
      background-size:cover;background-position:center;cursor:pointer;
    }
    .sonar-btn.disabled{opacity:.5;filter:grayscale(60%);cursor:pointer}

    /* ---- Sonar Modal ---- */
    .sonar-options{display:grid;gap:10px;margin-top:10px}
    .seg{display:flex;gap:8px;flex-wrap:wrap}
    .seg .chip{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:var(--chip);cursor:pointer;font-weight:700;color:#fff;}
    .seg .chip.active{outline:2px solid var(--accent)}
    .seg .chip.red{background:rgba(239,68,68,.18);border-color:#5b1e1e}
    .seg .chip.green{background:rgba(34,197,94,.18);border-color:#1b3e2a}
    .scan-area{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
    .scan-wait{display:none;gap:8px;align-items:center;color:var(--muted);font-weight:700}
    .scan-wait.visible{display:flex}
    .pulse{width:10px;height:10px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 0 rgba(96,165,250,.7);animation:pulse 1s infinite;}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(96,165,250,.7)}70%{box-shadow:0 0 0 18px rgba(96,165,250,0)}100%{box-shadow:0 0 0 0 rgba(96,165,250,0)}}

    /* ===== Controls: ONLY native geolocate; remove custom controls ===== */
    .maplibregl-ctrl-top-right{display:flex;flex-direction:column;gap:6px;}

    /* Audio toggle icon btn */
    .icon-btn{display:inline-grid;place-items:center;width:30px;height:30px;border:1px solid var(--border);border-radius:8px;background:var(--panel-2);cursor:pointer}
    .icon-btn svg{width:18px;height:18px}
  </style>
</head>
<body>
<div class="app" id="app">
  <button id="ui-reopen" class="ui-reopen" title="Open UI">Open UI</button>

  <aside class="sidebar" id="sidebar">
    <!-- Dark Veil background canvas -->
    <canvas id="darkveil" class="darkveil-canvas"></canvas>

    <div class="header">
      <div class="project-title">
        Sqkii Mapper
        <!-- Audio toggle -->
        <button id="audio-toggle" class="icon-btn" title="Audio on/off">...</button>
      </div>

      <!-- NEW: header toolbar with Edit toggle -->
      <div class="toolbar">
        <button id="edit-toggle" class="btn small" title="Toggle edit mode">Edit: OFF</button>
      </div>

      <button id="ui-hide" class="ui-hide" title="Hide UI">Hide UI</button>
    </div>

    <div class="mapstyle-row">
      <div class="mapstyle-left">
        <div class="label">Map style</div>
        <select id="basemap">
          <option value="custom" selected>Sqkii Purple Map (custom)</option>
          <option value="streets">MapTiler Streets</option>
          <option value="dark">MapTiler Dark</option>
          <option value="outdoor">MapTiler Outdoor</option>
          <option value="satellite">MapTiler Satellite</option>
          <option value="osm">OpenStreetMap (raster)</option>
        </select>
      </div>
      <div class="mapstyle-right">
        Autosaved
     </div>
    </div>

    <div style="padding:12px;border-bottom:1px solid var(--border); position:relative; z-index:1;">
      <div class="toolbar">
        <button class="btn small" id="upload-btn">Upload KML/KMZ</button>
        <input id="upload-input" type="file" accept=".kml,.kmz" multiple style="display:none" />
        <button class="btn small" id="add-layer">Add layer</button>
        <button class="btn small" id="export-kml">Export KML</button>
        <button class="btn small" id="export-kmz">Export KMZ</button>
      </div>

      <div class="row-split" style="margin-top:10px;">
        <input id="url-input" type="url" placeholder="https://example.com/map.kml or .kmz" />
        <button class="btn small" id="url-load">Load URL</button>
      </div>
    </div>

    <!-- Draw Circle quick tool -->
    <div style="padding:12px;border-bottom:1px solid var(--border);display:grid;gap:8px; position:relative; z-index:1;">
      <button class="btn" id="draw-circle">DRAW CIRCLE</button>

      <!-- two long rows: lat,lng then radius + Add -->
      <div id="draw-inputs" class="draw-grid" style="display:none;">
        <input id="draw-coord" type="text" placeholder="Latitude,Longitude (e.g. 1.3521,103.8198)" />
        <input id="draw-radius" type="number" min="1" step="1" placeholder="Radius (meters)" />
        <button class="btn small" id="draw-apply">Add</button>
      </div>
    </div>

    <details class="grp" id="group-visibility" open>
      <summary>Groups visibility</summary>
      <div class="grp-list" id="grp-list"></div>
    </details>

    <div id="layers"></div>
  </aside>

  <!-- Two engines -->
  <main id="mapgl"></main>
  <main id="mapleaf" style="display:none"></main>

  <!-- Long-press style editor -->
  <div id="style-editor" class="style-editor">
    <h4>Edit shape style</h4>
    <div class="style-row"><label>Fill</label><input id="se-fill" type="color" value="#ffffff"></div>
    <div class="style-row"><label>Opacity</label><input id="se-fillop" type="range" min="0" max="1" step="0.05" value="0.2"></div>
    <div class="style-row"><label>Outline</label><input id="se-outline" type="checkbox" checked></div>
    <div class="style-row"><label>Stroke</label><input id="se-stroke" type="color" value="#ffffff"></div>
    <div class="style-row"><label>Width</label><input id="se-width" type="number" min="0" max="20" step="0.5" value="2"></div>
    <div class="style-actions">
      <button class="btn small danger" id="se-delete">Delete</button>
      <button class="btn small" id="se-close">Close</button>
    </div>
  </div>
</div>

<!-- ===== Server Code Modal ===== -->
<div id="server-modal" class="modal visible">
  <div class="modal-card">
    <h3>Join a server</h3>
    <small>Enter your shared <strong>Server Code</strong> to sync with others.</small>
    <div class="modal-row">
      <input id="server-code-input" placeholder="e.g. gold-team" />
      <button id="server-code-join" class="btn small">Join</button>
    </div>
    <button id="server-continue" class="btn small" style="margin-top:8px">Continue without sync</button>
    <small>New code? We'll create it automatically.</small>
    <div id="server-error" class="err"></div>
  </div>
</div>

<!-- ===== Sonar Modal ===== -->
<div id="sonar-modal" class="modal">
  <div class="modal-card">
    <h3>Activate Coin Sonar</h3>
    <div class="hint">Choose radius and color, then scan from your current GPS.</div>

    <div class="sonar-options">
      <div>
        <div class="hint" style="margin-bottom:4px;">Radius</div>
        <div class="seg" id="sonar-radius">
          <button class="chip" data-radius="25">25 m</button>
          <button class="chip active" data-radius="50">50 m</button>
          <button class="chip" data-radius="100">100 m</button>
        </div>
      </div>

      <div>
        <div class="hint" style="margin-bottom:4px;">Color</div>
        <div class="seg" id="sonar-color">
          <button class="chip red active" data-color="red">RED</button>
          <button class="chip green" data-color="green">GREEN</button>
        </div>
      </div>
    </div>

    <div class="scan-area">
      <div id="scan-wait" class="scan-wait"><span class="pulse"></span> Scanning…</div>
      <button id="scan-now" class="btn">SCAN NOW</button>
    </div>
  </div>
</div>

<!-- Floating Sonar Button -->
<button id="sonar-btn" class="sonar-btn disabled" title="Turn on GPS to use Sonar"></button>

<script>
/* ================= Map engines ================= */
maptilersdk.config.apiKey = 'f9B8Wv0ythtbvpcK0QEw';
const CUSTOM_STYLE = 'https://api.maptiler.com/maps/01994e5b-af91-7fae-b8bd-a68c497abf96/style.json?key=' + maptilersdk.config.apiKey;

const mapgl = new maptilersdk.Map({ container:'mapgl', style:CUSTOM_STYLE, center:[103.8198,1.3521], zoom:12 });
function glReady(fn){ if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) fn(); else mapgl.once('load', fn); }

// Allow smoother fractional zoom (optional but feels nicer)
const mapleaf = L.map('mapleaf', {
  zoomControl: true,
  attributionControl: true,
  zoomSnap: 0.25,
  zoomDelta: 0.25
}).setView([1.3521,103.8198], 12);

// Default OSM tiles, but with Retina + higher logical max zoom
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxNativeZoom: 19,  // native limit of OSM server
  maxZoom: 22,        // let Leaflet scale beyond native
  detectRetina: true, // request higher-detail tiles for Hi-DPI
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(mapleaf);


let engine='gl';
function showGL(){ const c=mapleaf.getCenter(), z=mapleaf.getZoom(); document.getElementById('mapleaf').style.display='none'; document.getElementById('mapgl').style.display='block'; mapgl.resize(); mapgl.jumpTo({center:[c.lng,c.lat], zoom:z}); engine='gl'; }
function showLeaf(){ const c=mapgl.getCenter(), z=mapgl.getZoom(); document.getElementById('mapgl').style.display='none'; document.getElementById('mapleaf').style.display='block'; mapleaf.invalidateSize(true); mapleaf.setView([c.lat,c.lng], Math.round(z)); engine='leaf'; }

/* ================= Icon registry ================= */
const DOLLAR_ICON_NAME='dollar-pin'; let iconSeq=1;
const urlToName=new Map(), nameToUrl=new Map();
function dollarSvg(size){const s=size||64; return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 32 32"><circle cx="16" cy="16" r="13" fill="#111" stroke="white" stroke-width="1.5"/><text x="16" y="21" text-anchor="middle" font-family="system-ui,Segoe UI,Arial" font-size="16" font-weight="800" fill="white">$</text></svg>`;}
function addImageToGL(name, url){return new Promise(res=>{const img=new Image(); img.crossOrigin='anonymous'; img.referrerPolicy='no-referrer'; img.onload=()=>{try{mapgl.addImage(name,img,{pixelRatio:2});}catch{}res();}; img.onerror=()=>res(); img.src=url;});}
async function ensureDollarIcon(){ if(mapgl.hasImage && mapgl.hasImage(DOLLAR_ICON_NAME)) return; await addImageToGL(DOLLAR_ICON_NAME, 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(64))); }
function registerIconUrl(url){ if(!url) return DOLLAR_ICON_NAME; if(urlToName.has(url)) return urlToName.get(url); const name='icon-'+(iconSeq++); urlToName.set(url,name); nameToUrl.set(name,url); if(mapgl.isStyleLoaded&&mapgl.isStyleLoaded()) addImageToGL(name,url); else mapgl.once('load',()=>addImageToGL(name,url)); return name; }
async function ensureAllIconsOnCurrentStyle(){ await ensureDollarIcon(); for(const [url,name] of urlToName.entries()) if(!mapgl.hasImage(name)) await addImageToGL(name,url); }
mapgl.on('styleimagemissing', e=>{ const url=nameToUrl.get(e.id); if(url) addImageToGL(e.id,url); });

function readdAllGroupsAfterGLStyleChange() {
  let done = false;
  function hydrate() {
    if (done) return;
    done = true;
    (async () => {
      await ensureAllIconsOnCurrentStyle();
      layerList.forEach(e => {
        createGroupOnGL(e, true);
        if (e.visible === false && e.glLayerIds) {
          e.glLayerIds.forEach(lid => {
            if (mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid, 'visibility', 'none');
          });
        }
      });
      renderLayers();
      renderGroupsVisibility();
      
      // DON'T recreate GPS control on style changes
      // The existing control should persist across style changes
    })();
  }
  mapgl.once('load', hydrate);
  mapgl.once('idle', hydrate);
}

// Also add this CSS to hide any extra controls that might slip through
const style = document.createElement('style');
style.textContent = `
/* Hide duplicate geolocate controls - keep only the first one */
.maplibregl-ctrl-top-right .maplibregl-ctrl-group:has(.maplibregl-ctrl-geolocate) ~ .maplibregl-ctrl-group:has(.maplibregl-ctrl-geolocate) {
  display: none !important;
}
`;
document.head.appendChild(style);

/* ================= App state / utils ================= */
let layerSeq=1, featureSeq=1;
const layerList=[]; // {id,name,visible,data,items,glSourceId,glLayerIds[],lfGroup,lfLayers:Map,_deletedLayer?}
const byId=id=>document.getElementById(id);

function kmlColorToCss(aabbggrr){ if(!aabbggrr){return{hex:'#ffffff',opacity:0.2};} let s=aabbggrr.trim(); if(s.length===6) s='ff'+s; return {hex:'#'+s.slice(6,8)+s.slice(4,6)+s.slice(2,4), opacity:parseInt(s.slice(0,2),16)/255}; }
function defaultLabelFrom(n){ if(!n) return '•'; const c=(n.trim()[0]||'•').toUpperCase(); return /[A-Z0-9$]/.test(c)?c:'•'; }
function escapeHtml(s){return (s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));}
function sanitizeHtml(input){ try{ const parser=new DOMParser(); const doc=parser.parseFromString('<div>'+input+'</div>','text/html'); const allowedTags={A:1,B:1,I:1,EM:1,STRONG:1,P:1,BR:1,UL:1,OL:1,LI:1,IMG:1,DIV:1,SPAN:1}; const allowedAttrs={A:['href','title'], IMG:['src','alt','width','height','loading']}; (function clean(n){ for(const el of [...n.childNodes]){ if(el.nodeType===1){ if(!allowedTags[el.tagName]){ while(el.firstChild) n.insertBefore(el.firstChild,el); n.removeChild(el); continue; } for(const a of [...el.attributes]){ const ok=(allowedAttrs[el.tagName]||[]); if(!ok.includes(a.name.toLowerCase())) el.removeAttribute(a.name); } if(el.tagName==='A'){ const href=el.getAttribute('href')||''; el.setAttribute('target','_blank'); el.setAttribute('rel','noopener'); if(/^javascript:/i.test(href)) el.removeAttribute('href'); } if(el.tagName==='IMG'){ el.setAttribute('loading','lazy'); } clean(el); } } })(doc.body); return doc.body.firstChild.innerHTML; }catch(e){ return ''; } }
function findYouTubeId(str){ if(!str) return ''; const m=String(str).match(/(?:youtube\.com\/watch\?[^#\s]*v=|youtu\.be\/|youtube\.com\/embed\/)([A-Za-z0-9_-]{11})/); return m?m[1]:''; }
function buildYouTubeEmbed(id){ if(!id) return ''; const src='https://www.youtube-nocookie.com/embed/'+id+'?rel=0&modestbranding=1&playsinline=1'; return '<div class="yt-portrait" style="text-align:center"><iframe src="'+src+'" title="YouTube" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>'; }
function buildPopupHTMLFromProps(props){
  const name=props.name||'Feature'; const raw=props.description||''; const looksHtml=/<\/?[a-z][\s\S]*>/i.test(raw);
  let safe=looksHtml?sanitizeHtml(raw):escapeHtml(raw).replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" rel="noopener">$1</a>');
  const tmp=document.createElement('div'); tmp.innerHTML=safe; tmp.querySelectorAll('img').forEach(img=>img.remove()); safe=tmp.innerHTML;
  const id=findYouTubeId(raw)||findYouTubeId(tmp.textContent||''); const embed=buildYouTubeEmbed(id);
  return '<div style="min-width:260px;max-width:340px;">'
       + '<div style="font-weight:800;font-size:16px;margin-bottom:6px;text-align:center;">'+escapeHtml(name)+'</div>'
       + (embed || '')
       + (safe ? '<div style="font-size:13px;line-height:1.35;color:#cbd5e1;font-weight:700;">'+safe+'</div>' : '')
       + '</div>';
}
function bboxOfFeature(f){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; (function scan(c){ if(typeof c[0]==='number'){ const [x,y]=c; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);} else c.forEach(scan); })(f.geometry.coordinates); return [[minX,minY],[maxX,maxY]]; }
function panPopupIntoViewGL(lngLat,liftPx=220){ const p=mapgl.project(lngLat); p.y-=liftPx; const center=mapgl.unproject(p); mapgl.easeTo({center,duration:350}); }

/* Timestamps (match Sonar & Draw exactly) */
function timestampLabel(){ return new Date().toLocaleString(); }

/* ========== helpers for filtered rendering (exclude deleted) ========== */
function filteredFeatureCollection(entry){
  return { type:'FeatureCollection', features:(entry.data?.features||[]).filter(f=>!f?.properties?._deleted) };
}

/* ========= GHOST-LAYERS HEALERS ========= */
function hasLiveFeatures(entry){
  return !!(entry?.data?.features||[]).some(f => !(f?.properties?._deleted));
}
function normalizeDeletedFlag(entry){
  if(entry && entry._deletedLayer && hasLiveFeatures(entry)){
    entry._deletedLayer = false;
    return true;
  }
  return false;
}

/* ========== KMZ helpers ========== */
function blobToDataUrl(blob){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }
async function buildKmzAssetMap(zip){
  const out={};
  for(const f of Object.values(zip.files)){
    if(!f.dir && /\.(png|jpe?g|gif|svg)$/i.test(f.name)){
      const blob=await f.async('blob'); out[f.name] = await blobToDataUrl(blob);
    }
  }
  return out;
}
function resolveIconHref(href,opts){
  if(!href) return '';
  if(/^(https?:|data:)/i.test(href)) return href;
  if(opts && opts.assetMap){
    if(opts.assetMap[href]) return opts.assetMap[href];
    const base=href.split(/[\\/]/).pop();
    for(const k of Object.keys(opts.assetMap)){
      if(k===base || k.endsWith('/'+base)) return opts.assetMap[k];
    }
  }
  if(opts && opts.baseUrl){ try{return new URL(href,opts.baseUrl).href;}catch(e){} }
  return href;
}
function extractKmlMeta(xmlDoc,opts){ function t(n,sel){ const el=n.querySelector(sel); return el ? (el.textContent||'').trim():''; } const styleById={},smById={}; xmlDoc.querySelectorAll('Style[id], style[id]').forEach(s=>styleById[s.getAttribute('id')]=s); xmlDoc.querySelectorAll('StyleMap[id], styleMap[id]').forEach(s=>smById[s.getAttribute('id')]=s); function resolveStyleUrl(url){ if(!url) return null; const id=url.replace(/^#/,''); const sm=smById[id]; if(sm){ for(const p of sm.querySelectorAll('Pair')) if((t(p,'key')||'').toLowerCase()==='normal'){ const su=t(p,'styleUrl'); if(su) return resolveStyleUrl(su); } } return styleById[id]||null; } function topFolderName(node){ let cur=node.parentNode,top=''; while(cur&&cur.nodeType===1){ if(/Folder/i.test(cur.tagName)){ const nm=t(cur,'name'); if(nm) top=nm; } cur=cur.parentNode; } return top||'Untitled layer'; } function parseStyle(sEl){ if(!sEl) return {}; const iconHref=t(sEl,'IconStyle Icon href')||t(sEl,'iconStyle icon href'); const lineColor=t(sEl,'LineStyle color')||t(sEl,'lineStyle color'); const lineWidth=t(sEl,'LineStyle width')||t(sEl,'lineStyle width'); const polyColor=t(sEl,'PolyStyle color')||t(sEl,'polyStyle color'); return {iconHref:resolveIconHref(iconHref,opts),lineColor,lineWidth,polyColor}; } const metas=[]; xmlDoc.querySelectorAll('Placemark, placemark').forEach(pm=>{ const sEl=resolveStyleUrl(t(pm,'styleUrl')); metas.push({name:t(pm,'name'), topFolder:topFolderName(pm), style:parseStyle(sEl)}); }); return metas; }

/* ================= MapLibre overlay ================= */
function createGroupOnGL(entry, clearIfExists){
  glReady(async ()=>{
    await ensureAllIconsOnCurrentStyle();

    const srcId='src-'+entry.id, fillId='fill-'+entry.id, lineId='line-'+entry.id, iconId='icon-'+entry.id, lblId='lbl-'+entry.id, polyEdgeId='polyedge-'+entry.id;
    entry.glSourceId=srcId; entry.glLayerIds=[fillId,lineId,polyEdgeId,iconId,lblId];

    if(clearIfExists){
      [lblId,iconId,polyEdgeId,lineId,fillId].forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
      if(mapgl.getSource(srcId)) try{mapgl.removeSource(srcId);}catch{}
    }

    if(mapgl.getSource(srcId)) mapgl.removeSource(srcId);
    mapgl.addSource(srcId,{type:'geojson', promoteId:'fid', data:filteredFeatureCollection(entry)});

    const notHidden=['all',['!=',['get','hidden'],true],['!=',['get','_deleted'],true]];

    mapgl.addLayer({ id:fillId, type:'fill', source:srcId,
      filter:['all', notHidden, ['match', ['geometry-type'], ['Polygon','MultiPolygon'], true, false]],
      paint:{ 'fill-color':['coalesce',['get','_fill'],'#ffffff'], 'fill-opacity':['coalesce',['get','_fillOpacity'],0.2] } });

    mapgl.addLayer({ id:polyEdgeId, type:'line', source:srcId,
      filter:['all', notHidden, ['match', ['geometry-type'], ['Polygon','MultiPolygon'], true, false]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#ffffff'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.2] } });

    mapgl.addLayer({ id:lineId, type:'line', source:srcId,
      filter:['all', notHidden, ['match', ['geometry-type'], ['LineString','MultiLineString'], true, false]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#ffffff'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.2] } });

    mapgl.addLayer({ id:iconId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point'] ],
      layout:{ 'icon-image':['coalesce',['get','_icon'],DOLLAR_ICON_NAME], 'icon-size':['coalesce',['get','_iconSize'],1], 'icon-anchor':'bottom', 'icon-allow-overlap':true } });

    mapgl.addLayer({ id:lblId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point'] ],
      layout:{ 'text-field':['coalesce',['get','_label'],''], 'text-font':['Noto Sans Regular'], 'text-size':11, 'text-offset':[0,1.1], 'text-anchor':'top' },
      paint:{ 'text-color':'#e5e7eb','text-halo-color':'#0b0d11','text-halo-width':1.2 } });

    const POP=18;
    [fillId,polyEdgeId,lineId,iconId,lblId].forEach(lid=>{
      mapgl.on('click', lid, (e)=>{
        panPopupIntoViewGL(e.lngLat, 220);
        new maptilersdk.Popup({ anchor:'bottom', offset:[0,POP], maxWidth:'340px', closeOnClick:true })
          .setLngLat(e.lngLat).setHTML(buildPopupHTMLFromProps((e.features[0]&&e.features[0].properties)||{})).addTo(mapgl);
      });
    });

    attachLongPressGL(fillId, entry);
    attachLongPressGL(polyEdgeId, entry);
  });
}
function refreshGroupGL(entry){ const src=mapgl.getSource(entry.glSourceId); if(src) src.setData(filteredFeatureCollection(entry)); }

/* ================= Leaflet overlay ================= */
function dollarDataUrl(size=32){ return 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(size)); }
function leafletIconFor(url,size=32){ return L.icon({iconUrl:url||dollarDataUrl(size),iconSize:[size,size],iconAnchor:[size/2,size-2],popupAnchor:[0,-size/2]}); }
function createGroupOnLeaflet(entry,rebuild=false){
  if(rebuild && entry.lfGroup){ try{entry.lfGroup.remove();}catch{} }
  entry.lfGroup=L.layerGroup().addTo(mapleaf);
  entry.lfLayers=new Map();

  filteredFeatureCollection(entry).features.forEach(f=>{
    const fid=f.properties.fid, list=[];
    const strokeOn = (f.properties._strokeOpacity ?? 0.2) > 0 && (f.properties._weight ?? 2) > 0;
    const polyStyle={ color:f.properties._stroke||'#ffffff', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.2, fillColor:f.properties._fill||'#ffffff', fillOpacity:f.properties._fillOpacity ?? 0.2, stroke: strokeOn };
    const lineStyle={ color:f.properties._stroke||'#ffffff', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.2 };

    if(f.geometry.type==='Point'){
      const [lng,lat]=f.geometry.coordinates;
      const icon=leafletIconFor(f.properties._iconUrl || nameToUrl.get(f.properties._icon),32);
      const m=L.marker([lat,lng],{icon}).bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) m.addTo(entry.lfGroup); list.push(m);
    }else{
      const gj=L.geoJSON(f,{ style: geom=> (geom.type.includes('Polygon')?polyStyle:lineStyle) })
        .bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) gj.addTo(entry.lfGroup);
      list.push(gj);
      gj.on('mousedown', (ev)=> attachLongPressLeaf(ev, entry, fid));
      gj.on('touchstart', (ev)=> attachLongPressLeaf(ev, entry, fid));
    }
    entry.lfLayers.set(fid, list);
  });
}
function refreshGroupBoth(entry){
  refreshGroupGL(entry);
  if(entry.lfGroup){ try{ entry.lfGroup.clearLayers(); }catch{} createGroupOnLeaflet(entry, true); }
}

/* ================= UI ================= */

// --- Eye icon helpers for feature visibility ---
function eyeSvg(open = true){
  return open
    ? `<svg viewBox="0 0 24 24"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"/><circle cx="12" cy="12" r="3"/></svg>`
    : `<svg viewBox="0 0 24 24"><path d="M17.94 17.94A10.94 10.94 0 0 1 12 19C5 19 1 12 1 12a21.8 21.8 0 0 1 5.06-5.94"/><path d="M9.88 9.88A3 3 0 0 0 12 15a3 3 0 0 0 2.12-.88"/><path d="m1 1 22 22"/></svg>`;
}
function setEyeBtn(el, visible){
  el.innerHTML = eyeSvg(visible);
  el.classList.toggle('off', !visible);
  el.title = visible ? 'Hide feature' : 'Show feature';
  el.setAttribute('aria-pressed', String(visible));
}


function renderGroupsVisibility(){
  const host=byId('grp-list'); host.innerHTML='';
  // INCLUDE layers with live features even if _deletedLayer was set; also auto-heal
  const visibleLayers = layerList.filter(l => !l._deletedLayer || hasLiveFeatures(l));
  if(!visibleLayers.length){ host.innerHTML='<div class="hint">No groups yet.</div>'; return; }
  let healed=false; for(const L of visibleLayers){ healed = normalizeDeletedFlag(L) || healed; }
  if(healed) saveState();

  for(const entry of visibleLayers){
    const row=document.createElement('div'); row.className='grp-row';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=entry.visible!==false;
    const name=document.createElement('div'); name.textContent=entry.name;
    const count=document.createElement('div'); count.className='hint'; count.textContent=(entry.items||[]).length;
    cb.onchange=()=>{ entry.visible=cb.checked; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',cb.checked?'visible':'none'); }); if(entry.lfGroup){ if(cb.checked) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderLayers(); saveState(); };
    row.style.display='grid'; row.style.gridTemplateColumns='auto 1fr auto'; row.style.gap='8px';
    row.append(cb,name,count); host.appendChild(row);
  }
}
function renderLayers(){
  const host=byId('layers'); host.innerHTML='';
  // INCLUDE layers with live features even if _deletedLayer was set; also auto-heal
  const visibleLayers = layerList.filter(l => !l._deletedLayer || hasLiveFeatures(l));
  if(!visibleLayers.length){ host.innerHTML='<div class="layers-empty"><div class="hint">No layers yet. Upload or drop a KML/KMZ.</div></div>'; return; }
  let healed=false; for(const L of visibleLayers){ healed = normalizeDeletedFlag(L) || healed; }
  if(healed) saveState();

  for(const entry of visibleLayers){
    const visibleOnMap=entry.visible!==false;
    const wrap=document.createElement('div'); wrap.className='layer';
    const head=document.createElement('div'); head.className='layer-head';
    const vis=document.createElement('div'); vis.className=visibleOnMap?'toggle checked':'toggle'; vis.title='Show/Hide layer';
    vis.onclick=()=>{ entry.visible=!visibleOnMap; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',entry.visible?'visible':'none'); }); if(entry.lfGroup){ if(entry.visible) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderGroupsVisibility(); renderLayers(); saveState(); };

    const ttl=document.createElement('div'); ttl.className='title'; ttl.textContent=entry.name;

    const actions=document.createElement('div'); actions.className='actions';
    const renameBtn=document.createElement('button'); renameBtn.className='btn small'; renameBtn.textContent='Rename';
    renameBtn.onclick=()=>{ const nn=prompt('New layer name:', entry.name); if(!nn) return; entry.name=nn; renderGroupsVisibility(); renderLayers(); saveState(); };
    const delBtn=document.createElement('button'); delBtn.className='btn small'; delBtn.textContent='Delete';
    delBtn.onclick=()=>{ if(!confirm('Delete this layer for everyone?')) return;
      const tombs=[];
      for(const f of (entry.data?.features||[])){
        if(f?.properties?._deleted) continue;
        const key=f.properties._gid||f.properties.fid;
        tombs.push({ type:'Feature', geometry:{type:'Point',coordinates:[0,0]},
          properties:{ fid:key, _gid:key, _deleted:true, _ts:Date.now(), name:(f.properties?.name||'Deleted') }});
      }
      entry.data.features = tombs; entry.items = []; entry._deletedLayer = true; entry.visible=false;
      (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
      if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{}; 
      if(entry.lfGroup) try{entry.lfGroup.remove();}catch{};
      renderGroupsVisibility(); renderLayers(); saveState();
    };
    actions.append(renameBtn, delBtn);

    head.append(vis, ttl, actions); wrap.appendChild(head);

    if(visibleOnMap){
      const importLine=document.createElement('div'); importLine.className='import-line';
      const link=document.createElement('span'); link.className='link'; link.textContent='Import more';
      link.onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.kml,.kmz'; inp.onchange=ev=>{ const f=ev.target.files[0]; if(!f) return; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f,entry.name); else f.text().then(txt=>addKmlText(txt,f.name,{},entry.name)); }; inp.click(); };
      importLine.appendChild(link); wrap.appendChild(importLine);

      for(const it of (entry.items||[])){
        const row=document.createElement('div'); row.className='feature';
        const ico=document.createElement('div'); ico.className='group-bullet'; ico.textContent=it.label || '•';
        const name=document.createElement('div'); name.className='name'; name.textContent=it.name; name.onclick=()=> zoomToFeature(entry,it.fid);
        const moveBtn=document.createElement('button'); moveBtn.className='btn small'; moveBtn.textContent='Move';
        moveBtn.onclick=()=>{ const target=prompt('Move to group (existing or new):', entry.name); if(!target) return; moveFeatureToGroup(entry, it.fid, target); };

        // Eye visibility toggle (replaces green box)
        const eyeBtn = document.createElement('button');
        eyeBtn.type = 'button';
        eyeBtn.className = 'eye-btn';
        setEyeBtn(eyeBtn, it.visible !== false);   // uses helper added earlier

        eyeBtn.addEventListener('click', ()=>{
          it.visible = !(it.visible !== false);
          const gf = entry.data.features.find(f => String(f.properties.fid) === String(it.fid));
          if (gf){
            gf.properties.hidden = (it.visible === false);
            gf.properties._ts = Date.now();
            refreshGroupBoth(entry);
          }
          setEyeBtn(eyeBtn, it.visible !== false);
          saveState();
        });

        row.append(ico, name, moveBtn, eyeBtn); 
        wrap.appendChild(row);
      }
    }
    host.appendChild(wrap);
  }
}


function zoomToFeature(entry, fid){
  const f = entry.data.features.find(x => x.properties && String(x.properties.fid) === String(fid));
  if(!f) return;
  const b = bboxOfFeature(f);
  if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:600});
  else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]});
}


/* === Move feature to another group === */
function getOrCreateLayerByName(name){
  let entry = layerList.find(l => l.name === name && !l._deletedLayer);
  if(!entry){
    entry = { id:layerSeq++, name, visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
    renderGroupsVisibility(); renderLayers(); saveState();
  }
  return entry;
}
function rebuildItemsFromFeatures(features){
  return (features||[])
    .filter(f=>!f.properties?._deleted)
    .map(f=>({
      fid: String(f.properties?.fid),
      name: f.properties?.name || 'Feature',
      label: (f.geometry?.type==='Point') ? (f.properties?._label||'•') : '•',
      visible: !(f.properties?.hidden)
    }))
}

function moveFeatureToGroup(fromEntry, fid, targetName){
  const idx = fromEntry.data.features.findIndex(f => String(f.properties?.fid) === String(fid));
  if (idx < 0) return;

  const f = fromEntry.data.features[idx];
  const key = String(f.properties?._gid ?? f.properties?.fid ?? fid);

  // 1) Remove live feature from old layer
  fromEntry.data.features.splice(idx, 1);

  // 2) Add tombstone to old layer to signal delete across clients
  fromEntry.data.features.push({
    type: 'Feature',
    geometry: { type:'Point', coordinates:[0,0] },
    properties: {
      fid: key, _gid: key,
      _deleted: true,
      _ts: Date.now(),
      name: (f.properties?.name || 'Moved feature (tombstone)')
    }
  });
  fromEntry.items = rebuildItemsFromFeatures(fromEntry.data.features);
  refreshGroupBoth(fromEntry);

  // 3) Add the live feature to the target layer (preserve _gid)
  const toEntry = getOrCreateLayerByName(targetName);
  const moved = {
    type: 'Feature',
    geometry: f.geometry,
    properties: {
      ...f.properties,
      fid: key,           // keep fid stringified + stable
      _gid: key,
      hidden: false,
      _ts: Date.now()     // bump timestamp so the move wins
    }
  };
  toEntry.data.features.push(moved);
  toEntry.items = rebuildItemsFromFeatures(toEntry.data.features);
  refreshGroupBoth(toEntry);

  renderGroupsVisibility();
  renderLayers();
  saveState();
}


/* ================= Loaders ================= */
async function loadKMZFile(file,forceGroupName){ try{ const zip=await JSZip.loadAsync(file); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry){ alert('No .kml found inside KMZ: '+file.name); return; } const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,file.name,{assetMap},forceGroupName); }catch(e){ console.error(e); alert('Failed to read KMZ: '+file.name); } }
async function loadKMLFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const text=await res.text(); addKmlText(text,url.split('/').pop()||'remote.kml',{baseUrl:url},forceGroupName); }
async function loadKMZFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const blob=await res.blob(); const zip=await JSZip.loadAsync(blob); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry) throw new Error('No .kml inside KMZ'); const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,url.split('/').pop()||'remote.kmz',{assetMap,baseUrl:url},forceGroupName); }

function addKmlText(text,filename,opts,forceGroupName){
  const xml=new DOMParser().parseFromString(text,'text/xml');
  const metaList=extractKmlMeta(xml,opts||{});
  const gj=window.toGeoJSON.kml(xml);
  if(!gj || !gj.features || !gj.features.length){ alert('No features in '+filename); return; }

  const grouped={}; metaList.forEach((m,i)=>{ const f=forceGroupName||m.topFolder||'Untitled layer'; (grouped[f]||(grouped[f]=[])).push(i); });

  for(const gname of Object.keys(grouped)){
    const features=[], items=[];
    for(const idx of grouped[gname]){
      const f = gj.features[idx], m = metaList[idx], fid = String(featureSeq++);
      const props=f.properties||{}; const itemName=m.name||props.name||props.Name||props.title||('Feature '+fid);

      // Force default style: white fill + white outline @ 20% opacity
      const style={ _fill:'#ffffff', _fillOpacity:0.15, _stroke:'#ffffff', _strokeOpacity:0.7, _weight:2 };

      let iconName=DOLLAR_ICON_NAME, iconUrl='';
      const iconHref=m.style.iconHref;
      if(iconHref){ const name=registerIconUrl(iconHref); if(name) iconName=name; iconUrl=iconHref; }

      const isPoint=f.geometry && f.geometry.type==='Point';
      const label = isPoint ? defaultLabelFrom(itemName) : '•';

      const enriched={ type:'Feature', geometry:f.geometry,
        properties:{ ...props, name:itemName, fid, hidden:false, _label:isPoint?label:'', _icon:isPoint?iconName:undefined, _iconUrl:isPoint?iconUrl:undefined, _iconSize:1, _ts:Date.now(), _gid:fid, ...style } };
      features.push(enriched); items.push({fid,name:itemName,label,visible:true});
    }

    const entry={ id:layerSeq++, name:gname, visible:true, data:{type:'FeatureCollection',features}, items, glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
  }

  renderLayers(); renderGroupsVisibility(); saveState();
}

/* ========= Upload/URL ========= */
byId('upload-btn').onclick=()=>byId('upload-input').click();
byId('upload-input').addEventListener('change', ev=>{
  const files=[...(ev.target.files||[])];
  (function next(i){ if(i>=files.length){ ev.target.value=''; return; }
    const f=files[i];
    if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1));
    else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); });
  })(0);
});
byId('url-load').onclick=()=>{ const url=byId('url-input').value.trim(); if(!url) return; (/\.kmz(\?|#|$)/i.test(url) ? loadKMZFromUrl(url) : loadKMLFromUrl(url)).catch(e=>{ console.error(e); alert('Failed to load from URL (CORS or bad link).'); }); };

/* Add empty layer */
byId('add-layer').onclick=function(){ const entry={ id:layerSeq++, name:'Untitled layer', visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null }; layerList.push(entry); createGroupOnGL(entry); createGroupOnLeaflet(entry); renderLayers(); renderGroupsVisibility(); saveState(); };

/* ======= Circles helper (separate from Sonar) ======= */
function addCircleToLayer(centerLngLat, radius, color, layerName){
  const entry = getOrCreateLayerByName(layerName);
  const fid = String(featureSeq++);
  const hex = (color==='green') ? '#22c55e' : '#ef4444';
  const geom = circleGeoJSON(centerLngLat[0], centerLngLat[1], radius, 96);
  const name = `Circle ${radius}m (${(color||'red').toUpperCase()}) @ ${timestampLabel()}`;
  const props = { fid, name, hidden:false, _gid:fid, _ts:Date.now(), _fill:hex, _fillOpacity:0.18, _stroke:hex, _strokeOpacity:0.9, _weight:2 };
  entry.data.features.push({ type:'Feature', geometry:geom, properties:props });
  entry.items = rebuildItemsFromFeatures(entry.data.features);
  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  const b=bboxOfFeature({geometry:geom});
  if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:500}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]});
}

/* Draw Circle tool */
const drawBtn = byId('draw-circle'), drawBox = byId('draw-inputs');
drawBtn.addEventListener('click', ()=>{ drawBox.style.display = drawBox.style.display==='none'?'grid':'none'; });
byId('draw-apply').addEventListener('click', ()=>{
  const coord = byId('draw-coord').value.trim();
  const radius = parseFloat(byId('draw-radius').value);
  const m = coord.match(/^\s*([+-]?\d+(\.\d+)?)\s*,\s*([+-]?\d+(\.\d+)?)\s*$/);
  if(!m || !isFinite(radius) || radius<=0){ alert('Please enter "lat,lng" and a positive radius.'); return; }
  const lat = parseFloat(m[1]), lng = parseFloat(m[3]);
  addCircleToLayer([lng,lat], radius, 'red', 'Circles'); // always into Circles layer
});

/* ===== Sidebar minimize / reopen ===== */
const appEl=document.getElementById('app'), sidebarEl=document.getElementById('sidebar'), btnHide=document.getElementById('ui-hide'), btnReopen=document.getElementById('ui-reopen');
function collapseUI(){ appEl.classList.add('ui-collapsed'); document.documentElement.style.setProperty('--side','0px'); }
function expandUI(){ document.documentElement.style.setProperty('--side','320px'); appEl.classList.remove('ui-collapsed'); }
btnHide.addEventListener('click',collapseUI); btnReopen.addEventListener('click',expandUI);
sidebarEl.addEventListener('transitionend',e=>{ if(e.propertyName==='width'){ if(engine==='gl') mapgl.resize(); else mapleaf.invalidateSize(true); }});

/* ===== Basemap switching ===== */
document.getElementById('basemap').addEventListener('change', (e)=>{
  const val=e.target.value;
  if(val==='osm'){ showLeaf(); }
  else {
    if(val==='custom') mapgl.setStyle(CUSTOM_STYLE);
    else if(val==='streets') mapgl.setStyle(maptilersdk.MapStyle.STREETS);
    else if(val==='dark') mapgl.setStyle(maptilersdk.MapStyle.DARK);
    else if(val==='outdoor') mapgl.setStyle(maptilersdk.MapStyle.OUTDOOR);
    else if(val==='satellite') mapgl.setStyle(maptilersdk.MapStyle.SATELLITE);
    readdAllGroupsAfterGLStyleChange(); showGL();
  }
  closeStyleEditor();
});

/* ===== Preload sequence (optional assets) ===== */
const PRELOAD_GEOHASHES = 'geohashesGold.kmz';
const PRELOAD_COINS = ['All Coin Records 2023-2024.kmz','All Coins Record 2023-2024.kmz','All Coins Records 2023-2024.kmz'];

/* ===== Long-press style editor (Edit Mode) ===== */
const editorEl=byId('style-editor');
const seFill=byId('se-fill'), seFillOp=byId('se-fillop'), seOutline=byId('se-outline'), seStroke=byId('se-stroke'), seWidth=byId('se-width'), seClose=byId('se-close'), seDelete=byId('se-delete');
let editCtx=null, editingEnabled=false;
const editToggle = document.getElementById('edit-toggle');

function reflectEditUI(){
  if (!editToggle) return;
  editToggle.textContent = 'Edit: ' + (editingEnabled ? 'ON' : 'OFF');
  editToggle.classList.toggle('off', !editingEnabled);
}

// initial paint
reflectEditUI();

// Toggle button wiring
if (editToggle){
  editToggle.addEventListener('click', ()=>{
    editingEnabled = !editingEnabled;
    if (!editingEnabled) closeStyleEditor();
    reflectEditUI();
  });
}

// Keyboard shortcut (E)
document.addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase() === 'e' && !e.metaKey && !e.ctrlKey && !e.altKey){
    if (document.activeElement && /input|textarea|select/i.test(document.activeElement.tagName)) return;
    editingEnabled = !editingEnabled;
    if (!editingEnabled) closeStyleEditor();
    reflectEditUI();
    try{ localStorage.setItem('sqkii-editing', editingEnabled ? '1' : '0'); }catch{}
  }
});



function openStyleEditor(entry,fid,screenX,screenY){
  if(!editingEnabled) return;
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  editCtx = { entry, fid };

  seFill.value = p._fill || '#ffffff';
  seFillOp.value = (p._fillOpacity ?? 0.2);
  const strokeOn = (p._strokeOpacity ?? 0.2) > 0 && (p._weight ?? 2) > 0;
  seOutline.checked = strokeOn;
  seStroke.value = p._stroke || '#ffffff';
  seWidth.value = p._weight ?? 2;

  const left = Math.min(screenX+10, window.innerWidth-320);
  const top  = Math.max(10, Math.min(screenY-260, window.innerHeight-260));
  editorEl.style.left = left+'px';
  editorEl.style.top  = top+'px';
  editorEl.style.display='block';
}
function closeStyleEditor(){ editorEl.style.display='none'; editCtx=null; }
function applyEditor(){
  if(!editCtx) return;
  const {entry,fid}=editCtx;
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  p._fill = seFill.value;
  p._fillOpacity = parseFloat(seFillOp.value);
  if(seOutline.checked){ p._stroke = seStroke.value; p._weight = parseFloat(seWidth.value)||0; p._strokeOpacity = 0.9; }
  else { p._strokeOpacity = 0.0; p._weight = 0; }
  p._ts = Date.now();
  refreshGroupBoth(entry); saveState();
}
[seFill,seFillOp,seOutline,seStroke,seWidth].forEach(inp=> inp.addEventListener('input', applyEditor));
seClose.addEventListener('click', closeStyleEditor);

seDelete.addEventListener('click', ()=>{
  if(!editCtx) return;
  const {entry,fid}=editCtx;
  const ix = entry.data.features.findIndex(x=>x.properties.fid===fid);
  if(ix<0) return;
  const p = entry.data.features[ix].properties || {};
  if(!confirm('Delete this feature?')) return;

  entry.data.features.splice(ix,1);
  const key = p._gid || p.fid;
  entry.data.features.push({
    type:'Feature',
    geometry:{type:'Point',coordinates:[0,0]},
    properties:{ fid:key, _gid:key, _deleted:true, _ts:Date.now(), name:p.name||'Deleted feature' }
  });
  entry.items = rebuildItemsFromFeatures(entry.data.features);

  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  closeStyleEditor();
});

const LONGPRESS_MS = 500;
function attachLongPressGL(layerId, entry){
  let t=null;
  function clear(){ if(t){ clearTimeout(t); t=null; } }
  function start(e){
    if(!editingEnabled) return;
    const feat=e.features && e.features[0]; if(!feat) return;
    const type=feat.geometry && feat.geometry.type;
    if(type!=='Polygon' && type!=='MultiPolygon') return;
    const fid=feat.properties && feat.properties.fid;
    const pt=e.point||{x:0,y:0};
    t=setTimeout(()=>{ openStyleEditor(entry,fid, pt.x, pt.y); }, LONGPRESS_MS);
  }
  ['mousedown','touchstart'].forEach(ev=> mapgl.on(ev, layerId, start));
  ['mouseup','mouseleave','drag','move','touchend','touchcancel'].forEach(ev=> mapgl.on(ev, clear));
}
function attachLongPressLeaf(ev, entry, fid){
  if(!editingEnabled) return;
  let timer=null;
  function cancel(){ if(timer){ clearTimeout(timer); timer=null; } }
  const src = ev.originalEvent && ev.originalEvent.touches && ev.originalEvent.touches[0] ? ev.originalEvent.touches[0] : ev.originalEvent;
  timer=setTimeout(()=>{ const p=src; openStyleEditor(entry,fid, p.clientX, p.clientY); }, LONGPRESS_MS);
  document.addEventListener('mouseup', ()=>cancel(), {once:true});
  document.addEventListener('touchend', ()=>cancel(), {once:true});
}
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeStyleEditor(); });

/* ================= Autosave / Restore (local) ================= */
const LS_KEY='sqkii-mapper-state-v1';
function shallowSerializableState(){ return layerList.map(l=>({ id:l.id, name:l.name, visible:l.visible!==false, data:l.data, items:l.items, _deletedLayer: !!l._deletedLayer })); }
function localSaveOnly(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(shallowSerializableState())); }catch(e){ console.warn('Autosave failed',e); } }
window.addEventListener('beforeunload', localSaveOnly);

async function rebindFeatureIcons(entry){
  for (const f of (entry.data?.features || [])) {
    const p = f.properties || {};
    if (p._iconUrl) {
      const id = registerIconUrl(p._iconUrl);
      if (id) p._icon = id;
    } else if (p._icon == null) {
      p._icon = DOLLAR_ICON_NAME;
    }
  }
}
function clearAllLayers(){
  for(const entry of [...layerList]){
    (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
    if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{};
    if(entry.lfGroup) try{entry.lfGroup.remove();}catch{};
  }
  layerList.length = 0;
  renderGroupsVisibility(); renderLayers();
}

async function applyStateArray(arr){
  clearAllLayers();
  await ensureAllIconsOnCurrentStyle();

  for (const saved of (arr || [])){
    const entry = {
      id: (saved.id != null ? saved.id : (layerSeq++)),
      name: saved.name ?? 'Layer',
      visible: saved.visible !== false,
      data: saved.data,
      items: [],
      glSourceId: null,
      glLayerIds: [],
      lfGroup: null,
      lfLayers: null,
      _deletedLayer: !!saved._deletedLayer
    };

    // Normalize identifiers to strings (prevents GL/Leaflet promoteId mismatches)
    for (const f of (entry.data?.features || [])) {
      if (f?.properties?.fid   != null) f.properties.fid   = String(f.properties.fid);
      if (f?.properties?._gid  != null) f.properties._gid  = String(f.properties._gid);
    }

    await rebindFeatureIcons(entry);
    entry.items = rebuildItemsFromFeatures(entry.data?.features || []);

    // Heal ghost-layer flag if live features exist
    normalizeDeletedFlag(entry);

    layerList.push(entry);

    if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) {
      createGroupOnGL(entry);
    } else {
      mapgl.once('load', () => createGroupOnGL(entry));
    }
    createGroupOnLeaflet(entry);

    if (entry.visible === false){
      (entry.glLayerIds || []).forEach(lid => {
        if (mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid, 'visibility', 'none');
      });
      if (entry.lfGroup) mapleaf.removeLayer(entry.lfGroup);
    }
  }

  // Recompute seq counters (use only numeric fids for featureSeq)
  const numericFids = layerList
    .flatMap(l => (l.data?.features || []))
    .map(f => {
      const id = f?.properties?.fid;
      if (typeof id === 'number') return id;
      if (typeof id === 'string' && /^\d+$/.test(id)) return parseInt(id, 10);
      return NaN;
    })
    .filter(Number.isFinite);

  featureSeq = Math.max(0, ...(numericFids.length ? numericFids : [0])) + 1;
  layerSeq   = Math.max(0, ...layerList.map(l => Number(l.id) || 0)) + 1;

  renderGroupsVisibility();
  renderLayers();
}


/* =======================
   === SUPABASE INTEGRATION (merge-safe) ===
   ======================= */
const SUPABASE_URL = 'https://dfzsndktevcjjbtfwrvs.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNuZGt0ZXZjampidGZ3cnZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNDYxMzMsImV4cCI6MjA3MzYyMjEzM30.C9VbQMkl1Y4R-K5Dl2GwOxh58afFCQo5h2aK3RE8HpY';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let currentRoomCode = null;
const clientId = (()=>crypto.getRandomValues(new Uint32Array(4)).join('-'))();

function debounce(fn, ms){ let t=null; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

async function fetchRoom(code){
  const { data, error } = await supabase.from('rooms').select('*').eq('code', code).maybeSingle();
  if(error) throw error;
  return data;
}

/* ---- MERGING: prefer newest _ts; deletions via _deleted tombstones ---- */
async function upsertRoomState(code, state){
  const remote = await fetchRoom(code).catch(()=>null);
  const remoteState = (remote && Array.isArray(remote.state)) ? remote.state : [];
  const merged = mergeStates(remoteState, state);
  const { error } = await supabase.from('rooms').upsert({
    code,
    state: merged,
    updated_by: clientId,
    updated_at: new Date().toISOString()
  }, { onConflict:'code' });
  if(error) throw error;
}
function featureKey(f){ const p=f&&f.properties||{}; return String(p._gid ?? p.fid ?? ''); }
function newerFeature(a,b){ const ta=a?.properties?._ts ?? 0; const tb=b?.properties?._ts ?? 0; return (tb>ta)?b:a; }
function mergeLayer(remoteL, localL){
  if(!remoteL) return localL; if(!localL) return remoteL;
  const out={ id:remoteL.id??localL.id, name:remoteL.name??localL.name, visible:(localL.visible!==false)||(remoteL.visible!==false),
    data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null, _deletedLayer: (remoteL._deletedLayer||localL._deletedLayer)||false };
  const byKey=new Map();
  for(const f of (remoteL.data?.features||[])){ const k=featureKey(f)||`rf-${Math.random()}`; byKey.set(k,f); }
  for(const f of (localL.data?.features||[])){ const k=featureKey(f)||`lf-${Math.random()}`; byKey.set(k, byKey.has(k)?newerFeature(byKey.get(k),f):f); }
  out.data.features=[...byKey.values()];
  out.items = rebuildItemsFromFeatures(out.data.features);
  // HEAL after merge
  if (out._deletedLayer && hasLiveFeatures(out)) out._deletedLayer = false;
  return out;
}


function layerKeyId(L){ return (L && L.id != null) ? String(L.id) : ''; }
function layerKeyName(L){ return (L?.name || '').trim().toLowerCase(); }

function mergeStates(remoteArr, localArr){
  const byId   = new Map();
  const byName = new Map();

  // index remote by id and name (for matching)
  for (const L of (remoteArr || [])) {
    const kid = layerKeyId(L);
    const knm = layerKeyName(L);
    if (kid) byId.set(kid, L);
    if (knm) byName.set(knm, L);
  }

  const merged = [];
  const seenIds   = new Set();
  const seenNames = new Set();

  function markSeen(L){
    const kid = layerKeyId(L); if (kid) seenIds.add(kid);
    const knm = layerKeyName(L); if (knm) seenNames.add(knm);
  }
  function addOnceByKey(L){
    const kid = layerKeyId(L);
    const knm = layerKeyName(L);
    if ((kid && seenIds.has(kid)) || (knm && seenNames.has(knm))) return;
    merged.push(L);
    markSeen(L);
  }

  // merge locals with matching remotes (id first, else name)
  for (const localL of (localArr || [])) {
    const rid = layerKeyId(localL) ? byId.get(layerKeyId(localL)) : null;
    const rnm = !rid && layerKeyName(localL) ? byName.get(layerKeyName(localL)) : null;

    if (rid || rnm) {
      const remoteL = rid || rnm;
      const m = mergeLayer(remoteL, localL);

      // keep indices up to date for subsequent matches
      const kid = layerKeyId(m); if (kid) byId.set(kid, m);
      const knm = layerKeyName(m); if (knm) byName.set(knm, m);

      addOnceByKey(m);
    } else {
      // brand-new local layer
      addOnceByKey(localL);
      const kid = layerKeyId(localL); if (kid) byId.set(kid, localL);
      const knm = layerKeyName(localL); if (knm) byName.set(knm, localL);
    }
  }

  // add remaining remote layers not seen
  for (const L of (remoteArr || [])) addOnceByKey(L);

  return merged;
}


let suppressNextRemoteApply = false;

const syncToServerDebounced = debounce(async function(){
  if(!currentRoomCode) return;
  const state = shallowSerializableState();
  try{
    suppressNextRemoteApply = true;
    await upsertRoomState(currentRoomCode, state);
    localSaveOnly();
  }catch(e){
    console.warn('Supabase sync failed:', e);
  }finally{
    setTimeout(()=>{ suppressNextRemoteApply=false; }, 250);
  }
}, 350);

function saveState(){ syncToServerDebounced(); }

let roomChannel = null;
function subscribeRoom(code){
  try{
    if(roomChannel){ roomChannel.unsubscribe(); roomChannel=null; }
    roomChannel = supabase.channel('rooms-'+code)
      .on('postgres_changes',
        { event:'*', schema:'public', table:'rooms', filter:'code=eq.'+code },
        async payload=>{
          try{
            const row = payload.new || payload.record;
            if(!row) return;
            if(row.updated_by === clientId) return;
            if(suppressNextRemoteApply) return;
            await applyStateArray(row.state || []);
            localSaveOnly();
          }catch(e){ console.error('Apply remote state failed', e); }
        })
      .subscribe(()=>{});
  }catch(e){ console.error('subscribeRoom guard:', e); }
}

async function joinRoom(code){
  currentRoomCode = code;
  try{
    const existing = await fetchRoom(code);
    if(existing && existing.state && existing.state.length){
      await applyStateArray(existing.state);
    }else{
      clearAllLayers();
      try { await loadKMZFromUrl(encodeURI(PRELOAD_GEOHASHES), 'Geohashes'); } catch(e){ console.warn('Preload geohashes failed', e); }
      for (const name of PRELOAD_COINS){
        try { await loadKMZFromUrl(encodeURI(name)); console.log('Preloaded', name); break; }
        catch(e){ console.warn('Preload failed for', name); }
      }
      await upsertRoomState(code, shallowSerializableState());
    }
    subscribeRoom(code);
  }catch(e){
    console.error('Join failed', e);
    throw e;
  }
}

/* ===== Server Modal helpers ===== */
const modal = document.getElementById('server-modal');
const serverInput = document.getElementById('server-code-input');
const serverJoin = document.getElementById('server-code-join');
const serverErr = document.getElementById('server-error');
function showServerModal(){ modal.classList.add('visible'); appEl.classList.add('blocked-by-modal'); }
function hideServerModal(){ modal.classList.remove('visible'); appEl.classList.remove('blocked-by-modal'); }

serverJoin.addEventListener('click', async ()=>{
  const code = (serverInput.value||'').trim();
  if(!code){ serverErr.textContent='Please enter a server code.'; serverErr.style.display='block'; return; }
  serverErr.style.display='none';
  serverJoin.disabled=true; serverJoin.textContent='Joining...';
  try{
    await joinRoom(code);
    hideServerModal();
  }catch(e){
    console.error('Join failed', e);
    serverErr.textContent='Join failed: '+(e?.message||'Check connection / DNS / RLS / table.');
    serverErr.style.display='block';
  }finally{
    serverJoin.disabled=false; serverJoin.textContent='Join';
  }
});
document.getElementById('server-continue').addEventListener('click', ()=>{
  hideServerModal();
  try{ const raw=localStorage.getItem(LS_KEY); if(raw) applyStateArray(JSON.parse(raw)); }catch{}
});

/* ====================== AUDIO + SFX ====================== */
let audioEnabled = true;
const bgm = new Audio('Evening Traveler - Road Trip.mp3'); bgm.volume = 0.15; bgm.loop = true;
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) bgm.pause(); else if(audioEnabled) bgm.play().catch(()=>{}); });

let audioCtx = null, buttonBuffer = null;
const btnFallbackAudio = new Audio('button.mp3'); btnFallbackAudio.preload = 'auto';

(async ()=>{
  try{
    const res = await fetch('button.mp3', { cache:'force-cache' });
    const ab = await res.arrayBuffer();
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    try {
      buttonBuffer = await new Promise((resolve,reject)=>{
        const p = audioCtx.decodeAudioData(ab.slice(0), resolve, reject);
        if (p && typeof p.then === 'function') p.then(resolve).catch(reject);
      });
    } catch {
      audioCtx.decodeAudioData(ab.slice(0), buf=>buttonBuffer=buf, ()=>{});
    }
  }catch(e){ console.warn('button.mp3 preload failed', e); }
})();

function ensureAudioCtxResumed(){ try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch{} }
function playClick(){
  try{
    if(!audioEnabled) return;
    ensureAudioCtxResumed();
    if(buttonBuffer && audioCtx){
      const src = audioCtx.createBufferSource(); src.buffer = buttonBuffer; src.connect(audioCtx.destination); src.start(0);
    }else{
      btnFallbackAudio.currentTime = 0;
      btnFallbackAudio.play().catch(()=>{});
    }
  }catch(e){}
}
document.addEventListener('pointerdown', ()=>{
  ensureAudioCtxResumed();
  if(audioEnabled && !document.hidden){ bgm.play().catch(()=>{}); }
  playClick();
},{once:true,capture:true});

const audioBtn = document.getElementById('audio-toggle');
function setAudioIcon(on){
  audioBtn.innerHTML = on
    ? `<svg viewBox="0 0 24 24" fill="none" stroke="#e5e7eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>`
    : `<svg viewBox="0 0 24 24" fill="none" stroke="#e5e7eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="1" x2="1" y2="23"></line></svg>`;
}
setAudioIcon(true);
audioBtn.addEventListener('click', ()=>{
  audioEnabled = !audioEnabled;
  setAudioIcon(audioEnabled);
  if(!audioEnabled) bgm.pause(); else if(!document.hidden) bgm.play().catch(()=>{});
});
document.addEventListener('click', (ev)=>{ if(ev.target.closest('button')) playClick(); }, {capture:true});

const sonarSfx = new Audio('sonar-sound.mp3');

/* ====================== GPS CONTROLS ====================== */
let geolocate = null;

function ensureGeolocateControl() {
  if (geolocate) return geolocate; // Don't create if we already have one
  
  try {
    geolocate = new maptilersdk.GeolocateControl({
      positionOptions: { enableHighAccuracy: true },
      trackUserLocation: true,
      showUserLocation: true,
      showAccuracyCircle: true
    });
    
    mapgl.addControl(geolocate, 'top-right');
    
    // Add event listeners
    geolocate.on('geolocate', onFix);
    geolocate.on('trackuserlocationstart', () => setGpsState('TRACKING'));
    geolocate.on('trackuserlocationend', () => setGpsState('IDLE'));
    geolocate.on('error', (e) => console.warn('Geolocate error:', e));
    
  } catch (e) {
    console.error('Failed to add geolocate control:', e);
    geolocate = null;
  }
  
  return geolocate;
}

let lastUserPos = null; // [lng, lat]
const sonarBtn = byId('sonar-btn');

function updateSonarEnabled(){
  if(lastUserPos){ 
    if (sonarBtn.classList.contains('disabled')) {
      // First time GPS is activated
      sonarBtn.classList.remove('disabled'); 
      sonarBtn.title='Activate Coin Sonar';
      console.log('Sonar now available!');
    }
  } else { 
    sonarBtn.classList.add('disabled'); 
    sonarBtn.title='Turn on GPS to use Sonar'; 
  }
}

function setGpsState(state){ /* debug hook */ }

function onFix(e){
  const lng = e?.coords?.longitude ?? e?.lng ?? e?.lngLat?.lng;
  const lat = e?.coords?.latitude  ?? e?.lat ?? e?.lngLat?.lat;
  if (typeof lng==='number' && typeof lat==='number'){
    lastUserPos=[lng,lat]; 
    updateSonarEnabled();
    
    // Auto-enable sonar button when GPS activates
    if (sonarBtn.classList.contains('disabled')) {
      sonarBtn.classList.remove('disabled');
      sonarBtn.title = 'Activate Coin Sonar';
      console.log('Sonar activated - GPS location acquired');
    }
  }
}

mapgl.on('load', ()=> { ensureGeolocateControl(); });

/* ===== Sonar UI ===== */
const sonarModal = byId('sonar-modal');
const radiusSeg = byId('sonar-radius');
const colorSeg  = byId('sonar-color');
const scanNow   = byId('scan-now');
const scanWait  = byId('scan-wait');

let sonarRadius = 50;
let sonarColor  = 'red';

function openSonar(){ sonarModal.classList.add('visible'); appEl.classList.add('blocked-by-modal'); }
function closeSonar(){ sonarModal.classList.remove('visible'); appEl.classList.remove('blocked-by-modal'); scanWait.classList.remove('visible'); }

sonarBtn.addEventListener('click', ()=>{ 
  if(!lastUserPos){ 
    alert('Please enable GPS to use Sonar\n\nTurn on GPS using the location button in the top-right corner of the map, then try again.'); 
    return; 
  } 
  openSonar(); 
});

sonarModal.addEventListener('click', (e)=>{ if(e.target === sonarModal) closeSonar(); });
function setActiveChip(container, chip){ container.querySelectorAll('.chip').forEach(c=>c.classList.remove('active')); chip.classList.add('active'); }
radiusSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('.chip'); if(!btn) return; sonarRadius=parseInt(btn.dataset.radius,10)||50; setActiveChip(radiusSeg,btn); });
colorSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('.chip'); if(!btn) return; sonarColor=(btn.dataset.color==='green')?'green':'red'; setActiveChip(colorSeg,btn); });

/* ===== Geometry helpers ===== */
const sin=Math.sin, cos=Math.cos, asin=Math.asin, atan2=Math.atan2, PI=Math.PI;
function circleGeoJSON(lng, lat, radiusMeters, steps=96){
  const coords=[], R=6378137, d=radiusMeters/R, latRad=lat*PI/180, lngRad=lng*PI/180;
  for(let i=0;i<=steps;i++){
    const brng=(i/steps)*2*PI;
    const lat2=asin(sin(latRad)*cos(d)+cos(latRad)*sin(d)*cos(brng));
    const lng2=lngRad+atan2(sin(brng)*sin(d)*cos(latRad),cos(d)-sin(lat2));
    coords.push([lng2*180/PI, lat2*180/PI]);
  }
  return {type:'Polygon',coordinates:[coords]};
}

/* ===== Sonar layer management ===== */
function getOrCreateSonarLayer(){
  return getOrCreateLayerByName('Coin Sonar Scans');
}
function addSonarCircle(centerLngLat, radius, color){
  const entry = getOrCreateSonarLayer();
  const fid = `sonar-${clientId}-${Date.now()}-${Math.floor(Math.random()*1e6)}`;
  const hex = (color==='green') ? '#22c55e' : '#ef4444';
  const geom = circleGeoJSON(centerLngLat[0], centerLngLat[1], radius, 96);
  const name = `Sonar ${radius}m (${color.toUpperCase()}) @ ${timestampLabel()}`;
  const props = { fid, name, hidden:false, _gid:fid, _ts:Date.now(), _fill:hex, _fillOpacity:0.18, _stroke:hex, _strokeOpacity:0.9, _weight:2 };
  entry.data.features.push({ type:'Feature', geometry:geom, properties:props });
  entry.items = rebuildItemsFromFeatures(entry.data.features);
  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  const b=bboxOfFeature({geometry:geom});
  if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:500}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]});
}
scanNow.addEventListener('click', async ()=>{
  if(!lastUserPos){ alert('GPS not ready.'); return; }
  try{ sonarSfx.currentTime=0; if(audioEnabled) sonarSfx.play(); }catch{}
  scanWait.classList.add('visible'); scanNow.disabled=true;
  await new Promise(r=>setTimeout(r, 1000));
  addSonarCircle(lastUserPos, sonarRadius, sonarColor);
  scanNow.disabled=false; scanWait.classList.remove('visible'); closeSonar();
});

/* ================= Startup ================= */
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const urlParams = new URLSearchParams(location.search);
    const preCode = urlParams.get('server') || '';
    if(preCode){ serverInput.value = preCode; }
  }catch(e){ console.error('Startup guard:', e); }
  updateSonarEnabled();
});

/* ================= Export KML / KMZ ================= */
function escapeXml(s){return String(s).replace(/[<>&'"]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;' }[c]));}
function kmlColorFromCss(hex,opacity){ const h=(hex||'#ffffff').replace('#',''); const r=parseInt(h.slice(0,2),16)||0, g=parseInt(h.slice(2,4),16)||0, b=parseInt(h.slice(4,6),16)||0; const a=Math.round((opacity==null?1:opacity)*255); const to2=x=>x.toString(16).padStart(2,'0'); return to2(a)+to2(b)+to2(g)+to2(r); }
function serializePlacemark(f){
  const p=f.properties||{}, name=escapeXml(p.name||'Feature'), styleId='s'+(p.fid||'x');
  if(p._deleted) return '';
  let geomStr='';
  if(f.geometry.type==='Point'){ const [lng,lat]=f.geometry.coordinates; geomStr=`<Point><coordinates>${lng},${lat},0</coordinates></Point>`; }
  else if(f.geometry.type==='LineString'){ geomStr=`<LineString><coordinates>${f.geometry.coordinates.map(c=>c.join(',')).join(' ')}</coordinates></LineString>`; }
  else if(f.geometry.type==='Polygon'){
    const rings=f.geometry.coordinates.map((ring,i)=>`<${i===0?'outerBoundaryIs':'innerBoundaryIs'}><LinearRing><coordinates>${ring.map(c=>c.join(',')).join(' ')}</coordinates></LinearRing></${i===0?'outerBoundaryIs':'innerBoundaryIs'}>`).join('');
    geomStr=`<Polygon>${rings}</Polygon>`;
  } else return '';
  const style = `
    <Style id="${styleId}">
      <IconStyle>${p._iconUrl?`<Icon><href>${escapeXml(p._iconUrl)}</href></Icon>`:''}</IconStyle>
      <LineStyle><color>${kmlColorFromCss(p._stroke, p._strokeOpacity)}</color><width>${p._weight||2}</width></LineStyle>
      <PolyStyle><color>${kmlColorFromCss(p._fill, p._fillOpacity)}</color></PolyStyle>
    </Style>`;
  return style + `<Placemark><name>${name}</name><styleUrl>#${styleId}</styleUrl>${geomStr}${p.description?`<description><![CDATA[${p.description}]]></description>`:''}</Placemark>`;
}
function exportKMLString(){
  const body=layerList.map(l=>`<Folder><name>${escapeXml(l.name)}</name>${l.data.features.filter(f=>!f.properties.hidden && !f.properties._deleted).map(serializePlacemark).join('')}</Folder>`).join('');
  return `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>${body}</Document></kml>`;
}
function downloadBlob(name, blob){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }
byId('export-kml').onclick=()=>{ const kml=exportKMLString(); downloadBlob('sqkii-export.kml', new Blob([kml],{type:'application/vnd.google-earth.kml+xml'})); };
byId('export-kmz').onclick=async()=>{ const zip=new JSZip(); const kml=exportKMLString(); zip.file('doc.kml', kml); const blob=await zip.generateAsync({type:'blob'}); downloadBlob('sqkii-export.kmz', blob); };

<!-- ===== Dark Veil — pure WebGL (brighter & obvious purple) ===== -->

(function(){
  const c=document.getElementById('darkveil');if(!c)return;c.style.opacity=".5"; // make the overlay stronger
  const gl=c.getContext('webgl',{alpha:true,premultipliedAlpha:false})||c.getContext('experimental-webgl');if(!gl){console.warn('DarkVeil fallback');return;}
  const VS=`attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}`;
  const FS=`precision mediump float;uniform vec2 r;uniform float t,h,n,s,f,w;
  float rnd(vec2 p){return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);}
  mat3 r2y=mat3(0.299,0.587,0.114,0.596,-0.274,-0.322,0.211,-0.523,0.312),y2r=mat3(1.,0.956,0.621,1.,-0.272,-0.647,1.,-1.106,1.703);
  vec3 hue(vec3 c,float d){vec3 y=r2y*c;float a=radians(d),C=cos(a),S=sin(a);return clamp(y2r*vec3(y.x,y.y*C-y.z+S,y.y*S+y.z*C),0.,1.);}
  vec3 pat(vec2 u){float d=length(u),a=atan(u.y,u.x);float m=.55+.45*sin(4.0*d-1.4*t)+.35*cos(12.0*a+.8*t);float r=.15*sin(22.*u.x+.9*t)*cos(22.*u.y-.6*t);return vec3(m+r,m*.35,m*1.2);}
  vec3 sat(vec3 c,float k){float l=dot(c,vec3(.2126,.7152,.0722));return mix(vec3(l),c,k);}
  void main(){vec2 u=(gl_FragCoord.xy/r)*2.-1.;u.y*=-1.;u+=w*vec2(sin(u.y*6.283+.5*t),cos(u.x*6.283+.5*t))*.07;
    vec3 col=pat(u);col=hue(col,h);col=sat(col,1.7);                           // extra saturation
    col=mix(col,vec3(.80,.45,1.00),.70);                                       // strong purple tint
    col=vec3(col.r*1.45,col.g*.55,col.b*1.65);                                 // push R/B, suppress G
    col*=1.35; col=pow(col,vec3(.85));                                         // exposure + gamma brighten
    float sl=sin(gl_FragCoord.y*f)*.5+.5; col*=1.-(sl*sl)*s;                   // scanlines
    col+=(rnd(gl_FragCoord.xy+t)-.5)*n*.8; gl_FragColor=vec4(clamp(col,0.,1.),1.);
  }`;
  function S(t,s){const x=gl.createShader(t);gl.shaderSource(x,s);gl.compileShader(x);return x;}
  const pr=gl.createProgram();gl.attachShader(pr,S(gl.VERTEX_SHADER,VS));gl.attachShader(pr,S(gl.FRAGMENT_SHADER,FS));gl.linkProgram(pr);gl.useProgram(pr);
  const b=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,b);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,3,-1,-1,3]),gl.STATIC_DRAW);
  const a=gl.getAttribLocation(pr,'p');gl.enableVertexAttribArray(a);gl.vertexAttribPointer(a,2,gl.FLOAT,false,0,0);
  const uR=gl.getUniformLocation(pr,'r'),uT=gl.getUniformLocation(pr,'t');gl.uniform1f(gl.getUniformLocation(pr,'h'),300.0);
  gl.uniform1f(gl.getUniformLocation(pr,'n'),0.02);gl.uniform1f(gl.getUniformLocation(pr,'s'),0.06);gl.uniform1f(gl.getUniformLocation(pr,'f'),0.08);gl.uniform1f(gl.getUniformLocation(pr,'w'),0.08);
  const rs=()=>{const w=c.parentElement.clientWidth|0,h=c.parentElement.clientHeight|0;if(c.width!==w||c.height!==h){c.width=w;c.height=h;gl.viewport(0,0,w,h);}gl.uniform2f(uR,c.width,c.height)};addEventListener('resize',rs,{passive:true});rs();
  let st=performance.now(),raf;!function loop(){gl.uniform1f(uT,(performance.now()-st)/1e3);gl.drawArrays(gl.TRIANGLES,0,3);raf=requestAnimationFrame(loop)}();document.addEventListener('visibilitychange',()=>{if(document.hidden)cancelAnimationFrame(raf);else{st=performance.now();!function loop(){gl.uniform1f(uT,(performance.now()-st)/1e3);gl.drawArrays(gl.TRIANGLES,0,3);raf=requestAnimationFrame(loop)}();}});
})();


/* ===== EDITABLE KNOBS (Ultra-Blended) ===== */
const SPEED=0.2,ANGLE_SPEED=0.12,BRIGHTNESS=1.06,RES_SCALE=1.0;
const BASE_PURPLE=[0.50,0.32,0.96],ACC_LIGHT=[0.98,0.78,1.00],ACC_DARK=[0.36,0.08,0.60];
const STR1=0.55,WIDTH1=0.82,FREQ1=4.0,OFF1=0.05;  // light accent
const STR2=0.45,WIDTH2=0.80,FREQ2=5.2,OFF2=0.24;  // dark accent
const STR3=0.35,WIDTH3=0.84,FREQ3=3.0,OFF3=0.40;  // black darkener
const WARP=0.10,NOISE=0.010,SCAN_S=0.02,SCAN_F=0.08;

/* randomness */
const RAND_SEED=Math.random()*1000;  // change to re-seed
const RAND_WARP=0.12;                // spatial irregularity
const JIT_FREQ=0.30,JIT_WIDTH=0.25,JIT_OFFSET=0.30; // per-accent jitter
const JIT_DIR=0.28;                  // direction jitter
const RESEED_EVERY_SEC=0;            // e.g., 60 to reseed each minute

/* ===== DO NOT EDIT BELOW (minified) ===== */
(function(){const c=document.getElementById('darkveil');if(!c)return;c.style.opacity=".5";const gl=c.getContext('webgl',{alpha:!0,premultipliedAlpha:!1})||c.getContext('experimental-webgl');if(!gl){console.warn('DarkVeil fallback');return}const VS='attribute vec2 p;void main(){gl_Position=vec4(p,0.,1.);}';const FS='precision mediump float;uniform vec2 r;uniform float t,B,n,s,f,W,ang,seed;uniform float rw;uniform vec3 Cb,Lp,Dp;uniform vec4 A1,A2,A3;uniform vec3 J;uniform float jdir;float rnd(vec2 p){return fract(sin(dot(p,vec2(12.9898,78.233))+seed)*43758.5453);}float n1(vec2 p){vec2 i=floor(p),f=fract(p);vec2 u=f*f*(3.0-2.0*f);float a=rnd(i),b=rnd(i+vec2(1.,0.)),c=rnd(i+vec2(0.,1.)),d=rnd(i+vec2(1.,1.));return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);}vec2 warpN(vec2 p){vec2 g=vec2(n1(p*1.1+seed),n1(p*1.3-seed));return p+rw*(g-0.5);}vec2 warpS(vec2 p){return p+W*vec2(sin(2.1*p.y+0.9*t),cos(2.0*p.x-0.7*t));}float tri(float x){return 1.0-abs(fract(x)-0.5)*2.0;}float band(vec2 p,vec2 d,float freq,float width,float off,float k){p=warpS(warpN(p));float tf=t*mix(1.0,1.6,k);float jf=n1(p*1.2+tf*0.37+seed)-0.5;float jw=n1(p*1.5-tf*0.29-seed)-0.5;float jo=n1(p*0.9+tf*0.41+seed*0.5)-0.5;float F=freq*(1.0+J.x*jf),W=clamp(width*(1.0+J.y*jw),0.05,0.95),O=off+J.z*jo;float x=dot(p,d)*F - tf + O;float v=tri(x);return smoothstep(1.0-W,1.0,v);}void main(){vec2 uv=(gl_FragCoord.xy/r)*2.-1.;uv.y*=-1.;float asp=r.x/r.y;vec2 p=vec2(uv.x*asp,uv.y);float a=ang + jdir*(n1(vec2(ang*0.17,ang*0.23)+seed)-0.5);vec2 d=normalize(vec2(cos(a),sin(a)));vec3 col=Cb;float m1=band(p,d,A1.z,A1.y,A1.w,0.25);float m2=band(p,d,A2.z,A2.y,A2.w,0.55);float m3=band(p,d,A3.z,A3.y,A3.w,0.85);col=mix(col,Lp,clamp(m1*A1.x,0.,1.));col=mix(col,Dp,clamp(m2*A2.x,0.,1.));col=mix(col,vec3(0.),clamp(m3*A3.x,0.,1.));col*=B;col=pow(col,vec3(0.92));float sl=sin(gl_FragCoord.y*f)*.5+.5;col*=1.-(sl*sl)*s;col+=(rnd(gl_FragCoord.xy+t)-.5)*n*.8;gl_FragColor=vec4(clamp(col,0.,1.),1.);}';function S(t,s){const x=gl.createShader(t);gl.shaderSource(x,s);gl.compileShader(x);return x}const pr=gl.createProgram();gl.attachShader(pr,S(gl.VERTEX_SHADER,VS));gl.attachShader(pr,S(gl.FRAGMENT_SHADER,FS));gl.linkProgram(pr);gl.useProgram(pr);const b=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,b);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,3,-1,-1,3]),gl.STATIC_DRAW);const a=gl.getAttribLocation(pr,'p');gl.enableVertexAttribArray(a);gl.vertexAttribPointer(a,2,gl.FLOAT,!1,0,0);const uR=gl.getUniformLocation(pr,'r'),uT=gl.getUniformLocation(pr,'t'),uA=gl.getUniformLocation(pr,'ang');const uSeed=gl.getUniformLocation(pr,'seed');gl.uniform1f(gl.getUniformLocation(pr,'B'),BRIGHTNESS);gl.uniform1f(gl.getUniformLocation(pr,'n'),NOISE);gl.uniform1f(gl.getUniformLocation(pr,'s'),SCAN_S);gl.uniform1f(gl.getUniformLocation(pr,'f'),SCAN_F);gl.uniform1f(gl.getUniformLocation(pr,'W'),WARP);gl.uniform1f(gl.getUniformLocation(pr,'rw'),RAND_WARP);gl.uniform3f(gl.getUniformLocation(pr,'Cb'),BASE_PURPLE[0],BASE_PURPLE[1],BASE_PURPLE[2]);gl.uniform3f(gl.getUniformLocation(pr,'Lp'),ACC_LIGHT[0],ACC_LIGHT[1],ACC_LIGHT[2]);gl.uniform3f(gl.getUniformLocation(pr,'Dp'),ACC_DARK[0],ACC_DARK[1],ACC_DARK[2]);gl.uniform4f(gl.getUniformLocation(pr,'A1'),STR1,WIDTH1,FREQ1,OFF1);gl.uniform4f(gl.getUniformLocation(pr,'A2'),STR2,WIDTH2,FREQ2,OFF2);gl.uniform4f(gl.getUniformLocation(pr,'A3'),STR3,WIDTH3,FREQ3,OFF3);gl.uniform3f(gl.getUniformLocation(pr,'J'),JIT_FREQ,JIT_WIDTH,JIT_OFFSET);gl.uniform1f(gl.getUniformLocation(pr,'jdir'),JIT_DIR);const rs=()=>{const w=(c.parentElement?.clientWidth||c.width)|0,h=(c.parentElement?.clientHeight||c.height)|0,W=(w*RES_SCALE)|0,H=(h*RES_SCALE)|0;if(c.width!==W||c.height!==H){c.width=Math.max(1,W);c.height=Math.max(1,H);gl.viewport(0,0,c.width,c.height)}gl.uniform2f(uR,c.width,c.height)};addEventListener('resize',rs,{passive:!0});rs();let st=performance.now(),raf,lastSeed=RAND_SEED,seed=lastSeed,seedAt=0;(function loop(){const now=(performance.now()-st)/1e3;gl.uniform1f(uT,now*SPEED);gl.uniform1f(uA,now*ANGLE_SPEED);if(RESEED_EVERY_SEC>0&&(now-seedAt)>RESEED_EVERY_SEC){seedAt=now;seed=Math.random()*1000;}gl.uniform1f(uSeed,seed);gl.drawArrays(gl.TRIANGLES,0,3);raf=requestAnimationFrame(loop)})();document.addEventListener('visibilitychange',()=>{if(document.hidden)cancelAnimationFrame(raf);else{st=performance.now();(function loop(){const now=(performance.now()-st)/1e3;gl.uniform1f(uT,now*SPEED);gl.uniform1f(uA,now*ANGLE_SPEED);gl.uniform1f(uSeed,seed);gl.drawArrays(gl.TRIANGLES,0,3);raf=requestAnimationFrame(loop)})()}})})();




</script>
</body>
</html>
