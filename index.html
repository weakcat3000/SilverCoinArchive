<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SQKII Mapper</title>

  <!-- MapTiler SDK (MapLibre) -->
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.umd.min.js"></script>
  <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.css" rel="stylesheet" />

  <!-- Leaflet (OSM raster) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- togeojson + jszip -->
  <script src="https://unpkg.com/@tmcw/togeojson@4.7.0/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Supabase JS (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.5/dist/umd/supabase.min.js"></script>

  <!-- Preload button click sound for instant play -->
  <link rel="preload" href="button.mp3" as="audio" />

  <style>
    :root{
      --panel:#0f1115; --panel-2:#12151b; --muted:#98a2b3; --text:#e5e7eb;
      --accent:#60a5fa; --border:#1f2430; --bg:#0b0d11; --chip:#1c212e; --side:380px;
      --red:#ef4444; --green:#22c55e; --blue:#3b82f6;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    .app{position:relative;display:grid;grid-template-columns: var(--side) 1fr;height:100vh;transition:grid-template-columns .28s ease;}
    .ui-reopen{position:absolute;left:10px;top:10px;z-index:1100;display:none;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    .app.ui-collapsed .ui-reopen{display:inline-block;}
    .sidebar{position:relative;background:var(--panel);border-right:1px solid var(--border);overflow:auto;width:var(--side);transition:width .28s ease;}
    .header{padding:12px;border-bottom:1px solid var(--border);display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center}
    .project-title{font-weight:800;font-size:16px;display:flex;gap:8px;align-items:center}
    .toolbar{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;}
    .btn{background:var(--chip);border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-weight:600;cursor:pointer;color:var(--text);}
    .btn.small{padding:4px 8px;font-size:12px;}
    .hint{color:var(--muted);font-size:12px;}
    .row{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .row-split{display:grid;grid-template-columns:1fr 1fr auto;gap:8px;align-items:center}
    input[type="url"],select,input[type="text"],input[type="number"]{width:100%;box-sizing:border-box;border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:var(--panel-2);color:var(--text);}
    #mapgl, #mapleaf{height:100%;width:100%;}
    .dropzone{border:2px dashed var(--border);border-radius:12px;margin:12px;padding:14px;text-align:center;color:var(--muted);background:var(--panel-2);}
    .dropzone.dragover{border-color:var(--accent);color:var(--accent);background:#0e1729;}
    .layers-empty{padding:14px;}
    .layer{border-bottom:1px solid var(--border);background:var(--panel-2);}
    .layer+.layer{margin-top:10px;border-radius:10px;overflow:hidden;}
    .layer-head{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:10px 12px;}
    .layer-head .title{font-weight:700;}
    .layer-head .actions{display:flex;gap:6px;}
    .import-line{padding:8px 12px;background:#0e1420;border-top:1px solid var(--border);}
    .import-line .link{color:var(--accent);font-weight:600;cursor:pointer;}
    .feature{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px 12px;border-top:1px solid var(--border);}
    .feature .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .group-bullet{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;border:1px solid #2a3243;background:#11161f;color:#fff;font-size:12px;font-weight:800;}
    .toggle{display:inline-grid;place-items:center;width:16px;height:16px;border:1px solid #2a3243;border-radius:4px;background:#0f141d;cursor:pointer;}
    .toggle.checked{background:#16a34a;border-color:#16a34a;}
    details.grp{margin:10px 12px;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);}
    details.grp>summary{list-style:none;padding:10px 12px;cursor:pointer;font-weight:700;}
    details.grp>summary::-webkit-details-marker{display:none;}
    .grp-list{padding:8px 12px;display:grid;gap:6px;max-height:220px;overflow:auto;}
    .yt-portrait{width:240px;aspect-ratio:9/16;background:#000;border-radius:12px;overflow:hidden;margin:8px auto;}
    @media (min-width:480px){ .yt-portrait{ width:260px; } }
    .yt-portrait>iframe{width:100%;height:100%;display:block;border:0}
    .ui-hide{grid-column:3;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    a{color:var(--accent);}
    .maplibregl-popup-content{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .maplibregl-popup-tip{border-top-color:#0f1115 !important;border-bottom-color:#0f1115 !important;border-left-color:#0f1115 !important;border-right-color:#0f1115 !important;}
    .leaflet-popup-content-wrapper{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .leaflet-popup-tip{background:#0f1115;}
    .style-editor{position:fixed;z-index:1200;display:none;min-width:240px;max-width:280px;background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;padding:12px;box-shadow:0 12px 32px rgba(0,0,0,.45);}
    .style-editor h4{margin:0 0 8px 0;font-size:14px;}
    .style-row{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center;margin:8px 0;}
    .style-row input[type="color"],.style-row input[type="number"],.style-row input[type="range"]{width:100%;background:#12151b;border:1px solid #1f2430;color:#e5e7eb;border-radius:8px;padding:6px 8px;}
    .style-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:6px;}
    .style-actions .btn{padding:6px 10px;}
    .btn.danger{background:rgba(239,68,68,.1);border-color:#7f1d1d;color:#fecaca}

    /* ---- Server Code Modal + blocking ---- */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;place-items:center;z-index:2000;}
    .modal.visible{display:grid;}
    .modal-card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;max-width:380px;width:92%;box-shadow:0 12px 40px rgba(0,0,0,.5);}
    .modal-card h3{margin:0 0 8px 0;font-size:16px}
    .modal-row{display:grid;grid-template-columns:1fr auto;gap:8px;margin-top:8px}
    .modal small{color:var(--muted)}
    .modal .err{color:#f87171;font-weight:700;margin-top:6px;display:none}
    .app.blocked-by-modal{pointer-events:none;}
    .modal, .modal *{pointer-events:auto;}

    /* layout for the Map style row */
    .mapstyle-row{
      padding:12px;
      border-bottom:1px solid var(--border);
      display:grid;
      grid-template-columns: 1fr auto;
      gap:14px;
      align-items:start;
    }
    .mapstyle-right{
      color:var(--muted);
      font-size:12px;
      text-align:right;
      line-height:1.35;
      max-width:240px;
      padding-top:2px;
    }
    .mapstyle-left .label{
      color:var(--muted);
      font-size:12px;
      margin-bottom:4px;
    }

    /* Bigger white close button that sits just outside the popup corner */
    .maplibregl-popup-close-button{
      position:absolute; top:-8px; right:-8px; color:#fff !important; font-size:22px;
      width:28px; height:28px; line-height:28px; background:rgba(0,0,0,.55); border-radius:50%;
      border:none; box-shadow:0 2px 6px rgba(0,0,0,.35); text-shadow:none; opacity:1; z-index:2;
    }
    .maplibregl-popup-close-button:hover{ filter:brightness(1.15); }

    /* Leaflet */
    .leaflet-popup-close-button{
      position:absolute; top:-8px; right:-8px; color:#fff !important; font-size:22px;
      width:28px; height:28px; line-height:28px; background:rgba(0,0,0,.55); border-radius:50%;
      border:none; box-shadow:0 2px 6px rgba(0,0,0,.35); text-shadow:none; opacity:1; z-index:2;
    }
    .leaflet-popup-close-button:hover{ filter:brightness(1.15); }

    /* ---- Floating Sonar Button ---- */
    .sonar-btn{
      position:fixed;right:16px;bottom:16px;z-index:1500;width:64px;height:64px;border-radius:12px;background:#0e1420;
      border:1px solid var(--border);box-shadow:0 8px 24px rgba(0,0,0,.35);background-image:url('metal-sonar.png');
      background-size:cover;background-position:center;cursor:pointer;
    }
    .sonar-btn.disabled{opacity:.5;filter:grayscale(60%);pointer-events:none;cursor:not-allowed}

    /* ---- Sonar Modal ---- */
    .sonar-options{display:grid;gap:10px;margin-top:10px}
    .seg{display:flex;gap:8px;flex-wrap:wrap}
    .seg .chip{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:var(--chip);cursor:pointer;font-weight:700}
    .seg .chip.active{outline:2px solid var(--accent)}
    .seg .chip.red{background:rgba(239,68,68,.12);border-color:#5b1e1e}
    .seg .chip.green{background:rgba(34,197,94,.12);border-color:#1b3e2a}
    .scan-area{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}
    .scan-wait{display:none;gap:8px;align-items:center;color:var(--muted);font-weight:700}
    .scan-wait.visible{display:flex}
    .pulse{width:10px;height:10px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 0 rgba(96,165,250,.7);animation:pulse 1s infinite;}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(96,165,250,.7)}70%{box-shadow:0 0 0 18px rgba(96,165,250,0)}100%{box-shadow:0 0 0 0 rgba(96,165,250,0)}}

    /* ---- Custom control group (GPS + Edit) ---- */
    .custom-ctrl-group{margin-top:8px;}
    .custom-ctrl-group .ctrl-btn{
      width:32px;height:32px;display:grid;place-items:center;background:#fff;border:0;border-radius:2px;cursor:pointer;
      box-shadow:0 0 0 1px rgba(0,0,0,.1), 0 1px 2px rgba(0,0,0,.15);
    }
    .custom-ctrl-group .ctrl-btn + .ctrl-btn{margin-top:6px;}
    .ctrl-btn.blue{background:var(--blue);}
    .ctrl-btn.blue img{width:18px;height:18px;display:block;filter:invert(1) brightness(10);}
    .ctrl-btn.edit.active{outline:2px solid var(--accent);}
    .maplibregl-ctrl-top-right .maplibregl-ctrl-geolocate{display:none!important;}

    /* Audio toggle icon btn */
    .icon-btn{display:inline-grid;place-items:center;width:30px;height:30px;border:1px solid var(--border);border-radius:8px;background:var(--panel-2);cursor:pointer}
    .icon-btn svg{width:18px;height:18px}
  </style>
</head>
<body>
<div class="app" id="app">
  <button id="ui-reopen" class="ui-reopen" title="Open UI">Open UI</button>

  <aside class="sidebar" id="sidebar">
    <div class="header">
      <div class="project-title">
        SQKII MAPPER
        <!-- Audio toggle -->
        <button id="audio-toggle" class="icon-btn" title="Audio on/off">
          <!-- speaker with waves (on by default) -->
          <svg viewBox="0 0 24 24" fill="none" stroke="#e5e7eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
          </svg>
        </button>
      </div>
      <div></div>
      <button id="ui-hide" class="ui-hide" title="Hide UI">Hide UI</button>
    </div>

    <div class="mapstyle-row">
      <div class="mapstyle-left">
        <div class="label">Map style</div>
        <select id="basemap">
          <option value="custom" selected>Sqkii Purple Map</option>
          <option value="streets">MapTiler Streets</option>
          <option value="dark">MapTiler Dark</option>
          <option value="outdoor">MapTiler Outdoor</option>
          <option value="satellite">MapTiler Satellite</option>
          <option value="osm">OpenStreetMap</option>
        </select>
      </div>
      <div class="mapstyle-right">
        Autosaves to your browser ·<br/>Realtime sync via server code
     </div>
    </div>

    <div style="padding:12px;border-bottom:1px solid var(--border);">
      <div class="toolbar">
        <button class="btn small" id="upload-btn">Upload</button>
        <input id="upload-input" type="file" accept=".kml,.kmz" multiple style="display:none" />
        <button class="btn small" id="add-layer">Add layer</button>
        <button class="btn small" id="export-kml">Export KML</button>
        <button class="btn small" id="export-kmz">Export KMZ</button>
      </div>

      <div class="row-split" style="margin-top:10px;">
        <input id="url-input" type="url" placeholder="https://example.com/map.kml or .kmz" />
        <button class="btn small" id="url-load">Load URL</button>
      </div>
    </div>

    <div class="dropzone" id="dz">
      <div><strong>Drop KML/KMZ here</strong></div>
      <div class="hint">…or use the Upload button above</div>
    </div>

    <!-- Draw Circle quick tool -->
    <div style="padding:12px;border-bottom:1px solid var(--border);display:grid;gap:8px">
      <button class="btn" id="draw-circle">DRAW CIRCLE</button>
      <div id="draw-inputs" style="display:none;gap:8px" class="row-split">
        <input id="draw-coord" type="text" placeholder="Input Coordinates (lat,lng)" />
        <input id="draw-radius" type="number" min="1" step="1" placeholder="Radius (meters)" />
        <button class="btn small" id="draw-apply">Add</button>
      </div>
    </div>

    <details class="grp" id="group-visibility" open>
      <summary>Groups visibility</summary>
      <div class="grp-list" id="grp-list"></div>
    </details>

    <div id="layers"></div>
  </aside>

  <!-- Two engines -->
  <main id="mapgl"></main>
  <main id="mapleaf" style="display:none"></main>

  <!-- Long-press style editor -->
  <div id="style-editor" class="style-editor">
    <h4>Edit shape style</h4>
    <div class="style-row"><label>Fill</label><input id="se-fill" type="color" value="#0b57d0"></div>
    <div class="style-row"><label>Opacity</label><input id="se-fillop" type="range" min="0" max="1" step="0.05" value="0.2"></div>
    <div class="style-row"><label>Outline</label><input id="se-outline" type="checkbox" checked></div>
    <div class="style-row"><label>Stroke</label><input id="se-stroke" type="color" value="#0b57d0"></div>
    <div class="style-row"><label>Width</label><input id="se-width" type="number" min="0" max="20" step="0.5" value="2"></div>
    <div class="style-actions">
      <button class="btn small danger" id="se-delete">Delete</button>
      <button class="btn small" id="se-close">Close</button>
    </div>
  </div>
</div>

<!-- ===== Server Code Modal ===== -->
<div id="server-modal" class="modal visible">
  <div class="modal-card">
    <h3>Join a server</h3>
    <small>Enter your shared <strong>Server Code</strong> to sync with others.</small>
    <div class="modal-row">
      <input id="server-code-input" placeholder="e.g. gold-team" />
      <button id="server-code-join" class="btn small">Join</button>
    </div>
    <button id="server-continue" class="btn small" style="margin-top:8px">Continue without sync</button>
    <small>New code? We'll create it automatically.</small>
    <div id="server-error" class="err"></div>
  </div>
</div>

<!-- ===== Sonar Modal ===== -->
<div id="sonar-modal" class="modal">
  <div class="modal-card">
    <h3>Activate Coin Sonar</h3>
    <div class="hint">Choose radius and color, then scan from your current GPS.</div>

    <div class="sonar-options">
      <div>
        <div class="hint" style="margin-bottom:4px;">Radius</div>
        <div class="seg" id="sonar-radius">
          <button class="chip" data-radius="25">25 m</button>
          <button class="chip active" data-radius="50">50 m</button>
          <button class="chip" data-radius="100">100 m</button>
        </div>
      </div>

      <div>
        <div class="hint" style="margin-bottom:4px;">Color</div>
        <div class="seg" id="sonar-color">
          <button class="chip red active" data-color="red">RED</button>
          <button class="chip green" data-color="green">GREEN</button>
        </div>
      </div>
    </div>

    <div class="scan-area">
      <div id="scan-wait" class="scan-wait"><span class="pulse"></span> Scanning…</div>
      <button id="scan-now" class="btn">SCAN NOW</button>
    </div>
  </div>
</div>

<!-- Floating Sonar Button -->
<button id="sonar-btn" class="sonar-btn disabled" title="Turn on GPS to use Sonar"></button>

<script>
/* ================= Map engines ================= */
maptilersdk.config.apiKey = 'f9B8Wv0ythtbvpcK0QEw';
const CUSTOM_STYLE = 'https://api.maptiler.com/maps/01994e5b-af91-7fae-b8bd-a68c497abf96/style.json?key=' + maptilersdk.config.apiKey;

const mapgl = new maptilersdk.Map({ container:'mapgl', style:CUSTOM_STYLE, center:[103.8198,1.3521], zoom:12 });
function glReady(fn){ if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) fn(); else mapgl.once('load', fn); }

const mapleaf = L.map('mapleaf', { zoomControl:true, attributionControl:true }).setView([1.3521,103.8198], 12);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(mapleaf);

let engine='gl';
function showGL(){ const c=mapleaf.getCenter(), z=mapleaf.getZoom(); document.getElementById('mapleaf').style.display='none'; document.getElementById('mapgl').style.display='block'; mapgl.resize(); mapgl.jumpTo({center:[c.lng,c.lat], zoom:z}); engine='gl'; }
function showLeaf(){ const c=mapgl.getCenter(), z=mapgl.getZoom(); document.getElementById('mapgl').style.display='none'; document.getElementById('mapleaf').style.display='block'; mapleaf.invalidateSize(true); mapleaf.setView([c.lat,c.lng], Math.round(z)); engine='leaf'; }

/* ================= Icon registry ================= */
const DOLLAR_ICON_NAME='dollar-pin'; let iconSeq=1;
const urlToName=new Map(), nameToUrl=new Map();
function dollarSvg(size){const s=size||64; return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 32 32"><circle cx="16" cy="16" r="13" fill="#111" stroke="white" stroke-width="1.5"/><text x="16" y="21" text-anchor="middle" font-family="system-ui,Segoe UI,Arial" font-size="16" font-weight="800" fill="white">$</text></svg>`;}
function addImageToGL(name, url){return new Promise(res=>{const img=new Image(); img.crossOrigin='anonymous'; img.referrerPolicy='no-referrer'; img.onload=()=>{try{mapgl.addImage(name,img,{pixelRatio:2});}catch{}res();}; img.onerror=()=>res(); img.src=url;});}
async function ensureDollarIcon(){ if(mapgl.hasImage && mapgl.hasImage(DOLLAR_ICON_NAME)) return; await addImageToGL(DOLLAR_ICON_NAME, 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(64))); }
function registerIconUrl(url){ if(!url) return DOLLAR_ICON_NAME; if(urlToName.has(url)) return urlToName.get(url); const name='icon-'+(iconSeq++); urlToName.set(url,name); nameToUrl.set(name,url); if(mapgl.isStyleLoaded&&mapgl.isStyleLoaded()) addImageToGL(name,url); else mapgl.once('load',()=>addImageToGL(name,url)); return name; }
async function ensureAllIconsOnCurrentStyle(){ await ensureDollarIcon(); for(const [url,name] of urlToName.entries()) if(!mapgl.hasImage(name)) await addImageToGL(name,url); }
mapgl.on('styleimagemissing', e=>{ const url=nameToUrl.get(e.id); if(url) addImageToGL(e.id,url); });

function readdAllGroupsAfterGLStyleChange(){
  let done=false;
  function hydrate(){ if(done) return; done=true; (async()=>{
    await ensureAllIconsOnCurrentStyle();
    layerList.forEach(e=>{ createGroupOnGL(e,true); if(e.visible===false && e.glLayerIds){ e.glLayerIds.forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility','none'); }); }});
    renderLayers(); renderGroupsVisibility();
  })(); }
  mapgl.once('load', hydrate); mapgl.once('idle', hydrate);
}

/* ================= App state / utils ================= */
let layerSeq=1, featureSeq=1;
const layerList=[]; // {id,name,visible,data,items,glSourceId,glLayerIds[],lfGroup,lfLayers:Map,_deletedLayer?}
const byId=id=>document.getElementById(id);

function kmlColorToCss(aabbggrr){ if(!aabbggrr){return{hex:'#0b57d0',opacity:0.2};} let s=aabbggrr.trim(); if(s.length===6) s='ff'+s; return {hex:'#'+s.slice(6,8)+s.slice(4,6)+s.slice(2,4), opacity:parseInt(s.slice(0,2),16)/255}; }
function defaultLabelFrom(n){ if(!n) return '•'; const c=(n.trim()[0]||'•').toUpperCase(); return /[A-Z0-9$]/.test(c)?c:'•'; }
function escapeHtml(s){return (s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));}
function sanitizeHtml(input){ try{ const parser=new DOMParser(); const doc=parser.parseFromString('<div>'+input+'</div>','text/html'); const allowedTags={A:1,B:1,I:1,EM:1,STRONG:1,P:1,BR:1,UL:1,OL:1,LI:1,IMG:1,DIV:1,SPAN:1}; const allowedAttrs={A:['href','title'], IMG:['src','alt','width','height','loading']}; (function clean(n){ for(const el of [...n.childNodes]){ if(el.nodeType===1){ if(!allowedTags[el.tagName]){ while(el.firstChild) n.insertBefore(el.firstChild,el); n.removeChild(el); continue; } for(const a of [...el.attributes]){ const ok=(allowedAttrs[el.tagName]||[]); if(!ok.includes(a.name.toLowerCase())) el.removeAttribute(a.name); } if(el.tagName==='A'){ const href=el.getAttribute('href')||''; el.setAttribute('target','_blank'); el.setAttribute('rel','noopener'); if(/^javascript:/i.test(href)) el.removeAttribute('href'); } if(el.tagName==='IMG'){ el.setAttribute('loading','lazy'); } clean(el); } } })(doc.body); return doc.body.firstChild.innerHTML; }catch(e){ return ''; } }
function findYouTubeId(str){ if(!str) return ''; const m=String(str).match(/(?:youtube\.com\/watch\?[^#\s]*v=|youtu\.be\/|youtube\.com\/embed\/)([A-Za-z0-9_-]{11})/); return m?m[1]:''; }
function buildYouTubeEmbed(id){ if(!id) return ''; const src='https://www.youtube-nocookie.com/embed/'+id+'?rel=0&modestbranding=1&playsinline=1'; return '<div class="yt-portrait" style="text-align:center"><iframe src="'+src+'" title="YouTube" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>'; }
function buildPopupHTMLFromProps(props){
  const name=props.name||'Feature'; const raw=props.description||''; const looksHtml=/<\/?[a-z][\s\S]*>/i.test(raw);
  let safe=looksHtml?sanitizeHtml(raw):escapeHtml(raw).replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" rel="noopener">$1</a>');
  const tmp=document.createElement('div'); tmp.innerHTML=safe; tmp.querySelectorAll('img').forEach(img=>img.remove()); safe=tmp.innerHTML;
  const id=findYouTubeId(raw)||findYouTubeId(tmp.textContent||''); const embed=buildYouTubeEmbed(id);
  return '<div style="min-width:260px;max-width:340px;">'
       + '<div style="font-weight:800;font-size:16px;margin-bottom:6px;text-align:center;">'+escapeHtml(name)+'</div>'
       + (embed || '')
       + (safe ? '<div style="font-size:13px;line-height:1.35;color:#cbd5e1;font-weight:700;">'+safe+'</div>' : '')
       + '</div>';
}
function bboxOfFeature(f){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; (function scan(c){ if(typeof c[0]==='number'){ const [x,y]=c; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);} else c.forEach(scan); })(f.geometry.coordinates); return [[minX,minY],[maxX,maxY]]; }
function panPopupIntoViewGL(lngLat,liftPx=220){ const p=mapgl.project(lngLat); p.y-=liftPx; const center=mapgl.unproject(p); mapgl.easeTo({center,duration:350}); }

/* ========== helpers for filtered rendering (exclude deleted) ========== */
function filteredFeatureCollection(entry){
  return { type:'FeatureCollection', features:(entry.data?.features||[]).filter(f=>!f?.properties?._deleted) };
}

/* ========== KMZ helpers ========== */
function blobToDataUrl(blob){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }
async function buildKmzAssetMap(zip){
  const out={};
  for(const f of Object.values(zip.files)){
    if(!f.dir && /\.(png|jpe?g|gif|svg)$/i.test(f.name)){
      const blob=await f.async('blob'); out[f.name] = await blobToDataUrl(blob);
    }
  }
  return out;
}
function resolveIconHref(href,opts){
  if(!href) return '';
  if(/^(https?:|data:)/i.test(href)) return href;
  if(opts && opts.assetMap){
    if(opts.assetMap[href]) return opts.assetMap[href];
    const base=href.split(/[\\/]/).pop();
    for(const k of Object.keys(opts.assetMap)){
      if(k===base || k.endsWith('/'+base)) return opts.assetMap[k];
    }
  }
  if(opts && opts.baseUrl){ try{return new URL(href,opts.baseUrl).href;}catch(e){} }
  return href;
}
function extractKmlMeta(xmlDoc,opts){ function t(n,sel){ const el=n.querySelector(sel); return el ? (el.textContent||'').trim():''; } const styleById={},smById={}; xmlDoc.querySelectorAll('Style[id], style[id]').forEach(s=>styleById[s.getAttribute('id')]=s); xmlDoc.querySelectorAll('StyleMap[id], styleMap[id]').forEach(s=>smById[s.getAttribute('id')]=s); function resolveStyleUrl(url){ if(!url) return null; const id=url.replace(/^#/,''); const sm=smById[id]; if(sm){ for(const p of sm.querySelectorAll('Pair')) if((t(p,'key')||'').toLowerCase()==='normal'){ const su=t(p,'styleUrl'); if(su) return resolveStyleUrl(su); } } return styleById[id]||null; } function topFolderName(node){ let cur=node.parentNode,top=''; while(cur&&cur.nodeType===1){ if(/Folder/i.test(cur.tagName)){ const nm=t(cur,'name'); if(nm) top=nm; } cur=cur.parentNode; } return top||'Untitled layer'; } function parseStyle(sEl){ if(!sEl) return {}; const iconHref=t(sEl,'IconStyle Icon href')||t(sEl,'iconStyle icon href'); const lineColor=t(sEl,'LineStyle color')||t(sEl,'lineStyle color'); const lineWidth=t(sEl,'LineStyle width')||t(sEl,'lineStyle width'); const polyColor=t(sEl,'PolyStyle color')||t(sEl,'polyStyle color'); return {iconHref:resolveIconHref(iconHref,opts),lineColor,lineWidth,polyColor}; } const metas=[]; xmlDoc.querySelectorAll('Placemark, placemark').forEach(pm=>{ const sEl=resolveStyleUrl(t(pm,'styleUrl')); metas.push({name:t(pm,'name'), topFolder:topFolderName(pm), style:parseStyle(sEl)}); }); return metas; }

/* ================= MapLibre overlay ================= */
function createGroupOnGL(entry, clearIfExists){
  glReady(async ()=>{
    await ensureAllIconsOnCurrentStyle();

    const srcId='src-'+entry.id, fillId='fill-'+entry.id, lineId='line-'+entry.id, iconId='icon-'+entry.id, lblId='lbl-'+entry.id, polyEdgeId='polyedge-'+entry.id;
    entry.glSourceId=srcId; entry.glLayerIds=[fillId,lineId,polyEdgeId,iconId,lblId];

    if(clearIfExists){
      [lblId,iconId,polyEdgeId,lineId,fillId].forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
      if(mapgl.getSource(srcId)) try{mapgl.removeSource(srcId);}catch{}
    }

    if(mapgl.getSource(srcId)) mapgl.removeSource(srcId);
    mapgl.addSource(srcId,{type:'geojson', promoteId:'fid', data:filteredFeatureCollection(entry)});

    const notHidden=['all',['!=',['get','hidden'],true],['!=',['get','_deleted'],true]];

    mapgl.addLayer({ id:fillId, type:'fill', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['Polygon','MultiPolygon']]]],
      paint:{ 'fill-color':['coalesce',['get','_fill'],'#0b57d0'], 'fill-opacity':['coalesce',['get','_fillOpacity'],0.2] } });

    mapgl.addLayer({ id:polyEdgeId, type:'line', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['Polygon','MultiPolygon']]]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#0b57d0'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.9] } });

    mapgl.addLayer({ id:lineId, type:'line', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['LineString','MultiLineString']]]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#0b57d0'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.9] } });

    mapgl.addLayer({ id:iconId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point']],
      layout:{ 'icon-image':['coalesce',['get','_icon'],DOLLAR_ICON_NAME], 'icon-size':['coalesce',['get','_iconSize'],1], 'icon-anchor':'bottom', 'icon-allow-overlap':true } });

    mapgl.addLayer({ id:lblId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point']],
      layout:{ 'text-field':['coalesce',['get','_label'],''], 'text-font':['Noto Sans Regular'], 'text-size':11, 'text-offset':[0,1.1], 'text-anchor':'top' },
      paint:{ 'text-color':'#e5e7eb','text-halo-color':'#0b0d11','text-halo-width':1.2 } });

    const POP=18;
    [fillId,polyEdgeId,lineId,iconId,lblId].forEach(lid=>{
      mapgl.on('click', lid, (e)=>{
        panPopupIntoViewGL(e.lngLat, 220);
        new maptilersdk.Popup({ anchor:'bottom', offset:[0,POP], maxWidth:'340px', closeOnClick:true })
          .setLngLat(e.lngLat).setHTML(buildPopupHTMLFromProps((e.features[0]&&e.features[0].properties)||{})).addTo(mapgl);
      });
    });

    attachLongPressGL(fillId, entry);
    attachLongPressGL(polyEdgeId, entry);
  });
}
function refreshGroupGL(entry){ const src=mapgl.getSource(entry.glSourceId); if(src) src.setData(filteredFeatureCollection(entry)); }

/* ================= Leaflet overlay ================= */
function dollarDataUrl(size=32){ return 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(size)); }
function leafletIconFor(url,size=32){ return L.icon({iconUrl:url||dollarDataUrl(size),iconSize:[size,size],iconAnchor:[size/2,size-2],popupAnchor:[0,-size/2]}); }
function createGroupOnLeaflet(entry,rebuild=false){
  if(rebuild && entry.lfGroup){ try{entry.lfGroup.remove();}catch{} }
  entry.lfGroup=L.layerGroup().addTo(mapleaf);
  entry.lfLayers=new Map();

  filteredFeatureCollection(entry).features.forEach(f=>{
    const fid=f.properties.fid, list=[];
    const strokeOn = (f.properties._strokeOpacity ?? 0.9) > 0 && (f.properties._weight ?? 2) > 0;
    const polyStyle={ color:f.properties._stroke||'#0b57d0', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.9, fillColor:f.properties._fill||'#0b57d0', fillOpacity:f.properties._fillOpacity ?? 0.2, stroke: strokeOn };
    const lineStyle={ color:f.properties._stroke||'#0b57d0', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.9 };

    if(f.geometry.type==='Point'){
      const [lng,lat]=f.geometry.coordinates;
      const icon=leafletIconFor(f.properties._iconUrl || nameToUrl.get(f.properties._icon),32);
      const m=L.marker([lat,lng],{icon}).bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) m.addTo(entry.lfGroup); list.push(m);
    }else{
      const gj=L.geoJSON(f,{ style: geom=> (geom.type.includes('Polygon')?polyStyle:lineStyle) })
        .bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) gj.addTo(entry.lfGroup);
      list.push(gj);
      gj.on('mousedown', (ev)=> attachLongPressLeaf(ev, entry, fid));
      gj.on('touchstart', (ev)=> attachLongPressLeaf(ev, entry, fid));
    }
    entry.lfLayers.set(fid, list);
  });
}
function refreshGroupBoth(entry){
  refreshGroupGL(entry);
  if(entry.lfGroup){ try{ entry.lfGroup.clearLayers(); }catch{} createGroupOnLeaflet(entry, true); }
}

/* ================= UI ================= */
function renderGroupsVisibility(){
  const host=byId('grp-list'); host.innerHTML='';
  const visibleLayers = layerList.filter(l=>!l._deletedLayer);
  if(!visibleLayers.length){ host.innerHTML='<div class="hint">No groups yet.</div>'; return; }
  for(const entry of visibleLayers){
    const row=document.createElement('div'); row.className='grp-row';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=entry.visible!==false;
    const name=document.createElement('div'); name.textContent=entry.name;
    const count=document.createElement('div'); count.className='hint'; count.textContent=(entry.items||[]).length;
    cb.onchange=()=>{ entry.visible=cb.checked; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',cb.checked?'visible':'none'); }); if(entry.lfGroup){ if(cb.checked) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderLayers(); saveState(); };
    row.style.display='grid'; row.style.gridTemplateColumns='auto 1fr auto'; row.style.gap='8px';
    row.append(cb,name,count); host.appendChild(row);
  }
}
function renderLayers(){
  const host=byId('layers'); host.innerHTML='';
  const visibleLayers = layerList.filter(l=>!l._deletedLayer);
  if(!visibleLayers.length){ host.innerHTML='<div class="layers-empty"><div class="hint">No layers yet. Upload or drop a KML/KMZ.</div></div>'; return; }
  for(const entry of visibleLayers){
    const visibleOnMap=entry.visible!==false;
    const wrap=document.createElement('div'); wrap.className='layer';
    const head=document.createElement('div'); head.className='layer-head';
    const vis=document.createElement('div'); vis.className=visibleOnMap?'toggle checked':'toggle'; vis.title='Show/Hide layer';
    vis.onclick=()=>{ entry.visible=!visibleOnMap; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',entry.visible?'visible':'none'); }); if(entry.lfGroup){ if(entry.visible) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderGroupsVisibility(); renderLayers(); saveState(); };

    const ttl=document.createElement('div'); ttl.className='title'; ttl.textContent=entry.name;

    const actions=document.createElement('div'); actions.className='actions';
    const renameBtn=document.createElement('button'); renameBtn.className='btn small'; renameBtn.textContent='Rename';
    renameBtn.onclick=()=>{ const nn=prompt('New layer name:', entry.name); if(!nn) return; entry.name=nn; renderGroupsVisibility(); renderLayers(); saveState(); };
    const delBtn=document.createElement('button'); delBtn.className='btn small'; delBtn.textContent='Delete';
    delBtn.onclick=()=>{ if(!confirm('Delete this layer for everyone?')) return;
      const tombs=[];
      for(const f of (entry.data?.features||[])){
        if(f?.properties?._deleted) continue;
        const key=f.properties._gid||f.properties.fid;
        tombs.push({ type:'Feature', geometry:{type:'Point',coordinates:[0,0]},
          properties:{ fid:key, _gid:key, _deleted:true, _ts:Date.now(), name:(f.properties?.name||'Deleted') }});
      }
      entry.data.features = tombs; entry.items = []; entry._deletedLayer = true; entry.visible=false;
      (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
      if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{};
      if(entry.lfGroup) try{entry.lfGroup.remove();}catch{};
      renderGroupsVisibility(); renderLayers(); saveState();
    };
    actions.append(renameBtn, delBtn);

    head.append(vis, ttl, actions); wrap.appendChild(head);

    if(visibleOnMap){
      const importLine=document.createElement('div'); importLine.className='import-line';
      const link=document.createElement('span'); link.className='link'; link.textContent='Import more';
      link.onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.kml,.kmz'; inp.onchange=ev=>{ const f=ev.target.files[0]; if(!f) return; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f,entry.name); else f.text().then(txt=>addKmlText(txt,f.name,{},entry.name)); }; inp.click(); };
      importLine.appendChild(link); wrap.appendChild(importLine);

      for(const it of (entry.items||[])){
        const row=document.createElement('div'); row.className='feature';
        const ico=document.createElement('div'); ico.className='group-bullet'; ico.textContent=it.label || '•';
        const name=document.createElement('div'); name.className='name'; name.textContent=it.name; name.onclick=()=> zoomToFeature(entry,it.fid);
        const togg=document.createElement('div'); togg.className=it.visible!==false?'toggle checked':'toggle';
        togg.onclick=()=>{ it.visible=!(it.visible!==false); const gf=entry.data.features.find(f=>f.properties.fid===it.fid); if(gf){ gf.properties.hidden = it.visible===false; gf.properties._ts = Date.now(); refreshGroupBoth(entry); } togg.className=it.visible!==false?'toggle checked':'toggle'; saveState(); };
        row.append(ico,name,togg); wrap.appendChild(row);
      }
    }
    host.appendChild(wrap);
  }
}
function zoomToFeature(entry,fid){ const f=entry.data.features.find(x=>x.properties&&x.properties.fid===fid); if(!f) return; const b=bboxOfFeature(f); if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:600}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]}); }

/* ================= Loaders ================= */
async function loadKMZFile(file,forceGroupName){ try{ const zip=await JSZip.loadAsync(file); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry){ alert('No .kml found inside KMZ: '+file.name); return; } const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,file.name,{assetMap},forceGroupName); }catch(e){ console.error(e); alert('Failed to read KMZ: '+file.name); } }
async function loadKMLFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const text=await res.text(); addKmlText(text,url.split('/').pop()||'remote.kml',{baseUrl:url},forceGroupName); }
async function loadKMZFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const blob=await res.blob(); const zip=await JSZip.loadAsync(blob); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry) throw new Error('No .kml inside KMZ'); const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,url.split('/').pop()||'remote.kmz',{assetMap,baseUrl:url},forceGroupName); }

function addKmlText(text,filename,opts,forceGroupName){
  const xml=new DOMParser().parseFromString(text,'text/xml');
  const metaList=extractKmlMeta(xml,opts||{});
  const gj=window.toGeoJSON.kml(xml);
  if(!gj || !gj.features || !gj.features.length){ alert('No features in '+filename); return; }

  const grouped={}; metaList.forEach((m,i)=>{ const f=forceGroupName||m.topFolder||'Untitled layer'; (grouped[f]||(grouped[f]=[])).push(i); });

  for(const gname of Object.keys(grouped)){
    const features=[], items=[];
    for(const idx of grouped[gname]){
      const f=gj.features[idx], m=metaList[idx], fid=featureSeq++;
      const props=f.properties||{}; const itemName=m.name||props.name||props.Name||props.title||('Feature '+fid);

      const style={};
      if(m.style.lineColor){ const lc=kmlColorToCss(m.style.lineColor); style._stroke=lc.hex; style._strokeOpacity=lc.opacity; }
      if(m.style.lineWidth){ const w=parseFloat(m.style.lineWidth); if(!isNaN(w)) style._weight=w; }
      if(m.style.polyColor){ const pc=kmlColorToCss(m.style.polyColor); style._fill=pc.hex; style._fillOpacity=pc.opacity; }
      if(style._fillOpacity===undefined) style._fillOpacity=0.2;
      if(style._stroke===undefined) style._stroke='#0b57d0';
      if(style._weight===undefined) style._weight=2;
      if(style._strokeOpacity===undefined) style._strokeOpacity=0.9;

      let iconName=DOLLAR_ICON_NAME, iconUrl='';
      const iconHref=m.style.iconHref;
      if(iconHref){ const name=registerIconUrl(iconHref); if(name) iconName=name; iconUrl=iconHref; }

      const isPoint=f.geometry && f.geometry.type==='Point';
      const label = isPoint ? defaultLabelFrom(itemName) : '•';

      const enriched={ type:'Feature', geometry:f.geometry,
        properties:{ ...props, name:itemName, fid, hidden:false, _label:isPoint?label:'', _icon:isPoint?iconName:undefined, _iconUrl:isPoint?iconUrl:undefined, _iconSize:1, _ts:Date.now(), _gid:fid, ...style } };
      features.push(enriched); items.push({fid,name:itemName,label,visible:true});
    }

    const entry={ id:layerSeq++, name:gname, visible:true, data:{type:'FeatureCollection',features}, items, glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
  }

  renderLayers(); renderGroupsVisibility(); saveState();
}

/* ========= Upload/Drop/URL ========= */
byId('upload-btn').onclick=()=>byId('upload-input').click();
byId('upload-input').addEventListener('change', ev=>{
  const files=[...(ev.target.files||[])];
  (function next(i){ if(i>=files.length){ ev.target.value=''; return; }
    const f=files[i];
    if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1));
    else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); });
  })(0);
});
['dragenter','dragover','dragleave','drop'].forEach(evt=>{
  byId('dz').addEventListener(evt, e=>{
    e.preventDefault(); if(evt==='dragenter'||evt==='dragover') e.currentTarget.classList.add('dragover'); else if(evt==='dragleave') e.currentTarget.classList.remove('dragover');
    if(evt==='drop'){ e.currentTarget.classList.remove('dragover'); const files=[...(e.dataTransfer?.files||[])]; (function next(i){ if(i>=files.length) return; const f=files[i]; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1)); else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); }); })(0); }
  });
});
byId('url-load').onclick=()=>{ const url=byId('url-input').value.trim(); if(!url) return; (/\.kmz(\?|#|$)/i.test(url) ? loadKMZFromUrl(url) : loadKMLFromUrl(url)).catch(e=>{ console.error(e); alert('Failed to load from URL (CORS or bad link).'); }); };

/* Add empty layer */
byId('add-layer').onclick=function(){ const entry={ id:layerSeq++, name:'Untitled layer', visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null }; layerList.push(entry); createGroupOnGL(entry); createGroupOnLeaflet(entry); renderLayers(); renderGroupsVisibility(); saveState(); };

/* ======= Circles helper (separate from Sonar) ======= */
function getOrCreateLayerByName(name){
  let entry = layerList.find(l => l.name === name && !l._deletedLayer);
  if(!entry){
    entry = { id:layerSeq++, name, visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
    renderGroupsVisibility(); renderLayers(); saveState();
  }
  return entry;
}
function addCircleToLayer(centerLngLat, radius, color, layerName){
  const entry = getOrCreateLayerByName(layerName);
  const fid = featureSeq++; // numeric, avoids mixing with string IDs
  const hex = (color==='green') ? '#22c55e' : '#ef4444';
  const geom = circleGeoJSON(centerLngLat[0], centerLngLat[1], radius, 96);
  const name = `Circle ${radius}m (${color.toUpperCase()}) @ ${new Date().toLocaleString()}`;
  const props = { fid, name, hidden:false, _gid:fid, _ts:Date.now(), _fill:hex, _fillOpacity:0.18, _stroke:hex, _strokeOpacity:0.9, _weight:2 };
  entry.data.features.push({ type:'Feature', geometry:geom, properties:props });
  entry.items.push({ fid, name, label:'•', visible:true });
  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  const b=bboxOfFeature({geometry:geom});
  if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:500}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]});
}

/* Draw Circle tool */
const drawBtn = byId('draw-circle'), drawBox = byId('draw-inputs');
drawBtn.addEventListener('click', ()=>{ drawBox.style.display = drawBox.style.display==='none'?'grid':'none'; });
byId('draw-apply').addEventListener('click', ()=>{
  const coord = byId('draw-coord').value.trim();
  const radius = parseFloat(byId('draw-radius').value);
  const m = coord.match(/^\s*([+-]?\d+(\.\d+)?)\s*,\s*([+-]?\d+(\.\d+)?)\s*$/);
  if(!m || !isFinite(radius) || radius<=0){ alert('Please enter "lat,lng" and a positive radius.'); return; }
  const lat = parseFloat(m[1]), lng = parseFloat(m[3]);
  addCircleToLayer([lng,lat], radius, 'red', 'Circles'); // always into Circles layer
});

/* ===== Sidebar minimize / reopen ===== */
const appEl=document.getElementById('app'), sidebarEl=document.getElementById('sidebar'), btnHide=document.getElementById('ui-hide'), btnReopen=document.getElementById('ui-reopen');
function collapseUI(){ appEl.classList.add('ui-collapsed'); document.documentElement.style.setProperty('--side','0px'); }
function expandUI(){ document.documentElement.style.setProperty('--side','380px'); appEl.classList.remove('ui-collapsed'); }
btnHide.addEventListener('click',collapseUI); btnReopen.addEventListener('click',expandUI);
sidebarEl.addEventListener('transitionend',e=>{ if(e.propertyName==='width'){ if(engine==='gl') mapgl.resize(); else mapleaf.invalidateSize(true); }});

/* ===== Basemap switching ===== */
document.getElementById('basemap').addEventListener('change', (e)=>{
  const val=e.target.value;
  if(val==='osm'){ showLeaf(); }
  else {
    if(val==='custom') mapgl.setStyle(CUSTOM_STYLE);
    else if(val==='streets') mapgl.setStyle(maptilersdk.MapStyle.STREETS);
    else if(val==='dark') mapgl.setStyle(maptilersdk.MapStyle.DARK);
    else if(val==='outdoor') mapgl.setStyle(maptilersdk.MapStyle.OUTDOOR);
    else if(val==='satellite') mapgl.setStyle(maptilersdk.MapStyle.SATELLITE);
    readdAllGroupsAfterGLStyleChange(); showGL();
  }
  closeStyleEditor();
});

/* ===== Preload sequence ===== */
const PRELOAD_GEOHASHES = 'geohashesGold.kmz';
const PRELOAD_COINS = ['All Coin Records 2023-2024.kmz','All Coins Record 2023-2024.kmz','All Coins Records 2023-2024.kmz'];

/* ===== Long-press style editor (Edit Mode) ===== */
const editorEl=byId('style-editor');
const seFill=byId('se-fill'), seFillOp=byId('se-fillop'), seOutline=byId('se-outline'), seStroke=byId('se-stroke'), seWidth=byId('se-width'), seClose=byId('se-close'), seDelete=byId('se-delete');
let editCtx=null, editingEnabled=false;
function openStyleEditor(entry,fid,screenX,screenY){
  if(!editingEnabled) return;
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  seFill.value = p._fill || '#0b57d0';
  seFillOp.value = (p._fillOpacity ?? 0.2);
  const strokeOn = (p._strokeOpacity ?? 0.9) > 0 && (p._weight ?? 2) > 0;
  seOutline.checked = strokeOn;
  seStroke.value = p._stroke || '#0b57d0';
  seWidth.value = p._weight ?? 2;

  const left = Math.min(screenX+10, window.innerWidth-300);
  const top  = Math.max(10, Math.min(screenY-260, window.innerHeight-260));
  editorEl.style.left = left+'px';
  editorEl.style.top  = top+'px';
  editorEl.style.display='block';
}
function closeStyleEditor(){ editorEl.style.display='none'; editCtx=null; }
function applyEditor(){
  if(!editCtx) return;
  const {entry,fid}=editCtx;
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  p._fill = seFill.value;
  p._fillOpacity = parseFloat(seFillOp.value);
  if(seOutline.checked){ p._stroke = seStroke.value; p._weight = parseFloat(seWidth.value)||0; p._strokeOpacity = 0.9; }
  else { p._strokeOpacity = 0.0; p._weight = 0; }
  p._ts = Date.now();
  refreshGroupBoth(entry); saveState();
}
[seFill,seFillOp,seOutline,seStroke,seWidth].forEach(inp=> inp.addEventListener('input', applyEditor));
seClose.addEventListener('click', closeStyleEditor);

seDelete.addEventListener('click', ()=>{
  if(!editCtx) return;
  const {entry,fid}=editCtx;
  const ix = entry.data.features.findIndex(x=>x.properties.fid===fid);
  if(ix<0) return;
  const p = entry.data.features[ix].properties || {};
  if(!confirm('Delete this feature?')) return;

  entry.data.features.splice(ix,1);
  const key = p._gid || p.fid;
  entry.data.features.push({
    type:'Feature',
    geometry:{type:'Point',coordinates:[0,0]},
    properties:{ fid:key, _gid:key, _deleted:true, _ts:Date.now(), name:p.name||'Deleted feature' }
  });
  const itx = (entry.items||[]).findIndex(it=>String(it.fid)===String(fid));
  if(itx>=0) entry.items.splice(itx,1);

  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  closeStyleEditor();
});

const LONGPRESS_MS = 850;
function attachLongPressGL(layerId, entry){
  let t=null;
  function clear(){ if(t){ clearTimeout(t); t=null; } }
  function start(e){
    if(!editingEnabled) return;
    const feat=e.features && e.features[0]; if(!feat) return;
    const type=feat.geometry && feat.geometry.type;
    if(type!=='Polygon' && type!=='MultiPolygon') return;
    const fid=feat.properties && feat.properties.fid;
    const pt=e.point||{x:0,y:0};
    t=setTimeout(()=>{ openStyleEditor(entry,fid, pt.x, pt.y); }, LONGPRESS_MS);
  }
  ['mousedown','touchstart'].forEach(ev=> mapgl.on(ev, layerId, start));
  ['mouseup','mouseleave','drag','move','touchend','touchcancel'].forEach(ev=> mapgl.on(ev, clear));
}
function attachLongPressLeaf(ev, entry, fid){
  if(!editingEnabled) return;
  let timer=null;
  function cancel(){ if(timer){ clearTimeout(timer); timer=null; } }
  timer=setTimeout(()=>{ const p=ev.originalEvent && ev.originalEvent.touches && ev.originalEvent.touches[0] ? ev.originalEvent.touches[0] : ev.originalEvent; openStyleEditor(entry,fid, p.clientX, p.clientY); }, LONGPRESS_MS);
  document.addEventListener('mouseup', ()=>cancel(), {once:true});
  document.addEventListener('touchend', ()=>cancel(), {once:true});
}
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeStyleEditor(); });

/* ================= Autosave / Restore (local) ================= */
const LS_KEY='sqkii-mapper-state-v1';
function shallowSerializableState(){ return layerList.map(l=>({ id:l.id, name:l.name, visible:l.visible!==false, data:l.data, items:l.items, _deletedLayer: !!l._deletedLayer })); }
function localSaveOnly(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(shallowSerializableState())); }catch(e){ console.warn('Autosave failed',e); } }
window.addEventListener('beforeunload', localSaveOnly);

async function rebindFeatureIcons(entry){
  for (const f of (entry.data?.features || [])) {
    const p = f.properties || {};
    if (p._iconUrl) {
      const id = registerIconUrl(p._iconUrl);
      if (id) p._icon = id;
    } else if (p._icon == null) {
      p._icon = DOLLAR_ICON_NAME;
    }
  }
}
function clearAllLayers(){
  for(const entry of [...layerList]){
    (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
    if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{};
    if(entry.lfGroup) try{entry.lfGroup.remove();}catch{};
  }
  layerList.length = 0;
  renderGroupsVisibility(); renderLayers();
}
async function applyStateArray(arr){
  clearAllLayers();
  await ensureAllIconsOnCurrentStyle();
  for (const saved of (arr||[])){
    const entry={ id:saved.id ?? layerSeq++, name:saved.name ?? 'Layer', visible:saved.visible!==false, data:saved.data, items:saved.items||[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null, _deletedLayer: !!saved._deletedLayer };
    await rebindFeatureIcons(entry);
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
    if(entry.visible === false){
      (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility','none'); });
      if(entry.lfGroup) mapleaf.removeLayer(entry.lfGroup);
    }
  }
  // >>> FIX: only consider numeric fids for featureSeq <<<
  const allNumericFids = layerList.flatMap(l => (l.data?.features||[]).map(f => Number(f.properties?.fid)||0));
  featureSeq = Math.max(0, ...allNumericFids, 0) + 1;
  layerSeq = Math.max( ...layerList.map(l=>Number(l.id)||0), 0 ) + 1;

  renderGroupsVisibility(); renderLayers();
}

/* =======================
   === SUPABASE INTEGRATION (merge-safe) ===
   ======================= */
const SUPABASE_URL = 'https://dfzsndktevcjjbtfwrvs.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmenNuZGt0ZXZjampidGZ3cnZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNDYxMzMsImV4cCI6MjA3MzYyMjEzM30.C9VbQMkl1Y4R-K5Dl2GwOxh58afFCQo5h2aK3RE8HpY';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let currentRoomCode = null;
const clientId = (()=>crypto.getRandomValues(new Uint32Array(4)).join('-'))();

function debounce(fn, ms){ let t=null; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

async function fetchRoom(code){
  const { data, error } = await supabase.from('rooms').select('*').eq('code', code).maybeSingle();
  if(error) throw error;
  return data;
}

/* ---- MERGING: prefer newest _ts; deletions via _deleted tombstones ---- */
async function upsertRoomState(code, state){
  const remote = await fetchRoom(code).catch(()=>null);
  const remoteState = (remote && Array.isArray(remote.state)) ? remote.state : [];
  const merged = mergeStates(remoteState, state);
  const { error } = await supabase.from('rooms').upsert({
    code,
    state: merged,
    updated_by: clientId,
    updated_at: new Date().toISOString()
  }, { onConflict:'code' });
  if(error) throw error;
}
function featureKey(f){ const p=f&&f.properties||{}; return String(p._gid ?? p.fid ?? ''); }
function newerFeature(a,b){ const ta=a?.properties?._ts ?? 0; const tb=b?.properties?._ts ?? 0; return (tb>ta)?b:a; }
function mergeLayer(remoteL, localL){
  if(!remoteL) return localL; if(!localL) return remoteL;
  const out={ id:remoteL.id??localL.id, name:remoteL.name??localL.name, visible:(localL.visible!==false)||(remoteL.visible!==false),
    data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null, _deletedLayer: (remoteL._deletedLayer||localL._deletedLayer)||false };
  const byKey=new Map();
  for(const f of (remoteL.data?.features||[])){ const k=featureKey(f)||`rf-${Math.random()}`; byKey.set(k,f); }
  for(const f of (localL.data?.features||[])){ const k=featureKey(f)||`lf-${Math.random()}`; byKey.set(k, byKey.has(k)?newerFeature(byKey.get(k),f):f); }
  out.data.features=[...byKey.values()];
  out.items = out.data.features
    .filter(f=>!f.properties?._deleted)
    .map(f=>({ fid:f.properties?.fid, name:f.properties?.name||'Feature', label:(f.geometry?.type==='Point')?(f.properties?._label||'•'):'•', visible:!(f.properties?.hidden) }));
  return out;
}
function layerKey(L){ return String(L?.name ?? L?.id ?? ''); }
function mergeStates(remoteArr, localArr){
  const out=new Map();
  for(const L of (remoteArr||[])) out.set(layerKey(L), L);
  for(const L of (localArr||[])){ const k=layerKey(L); out.set(k, out.has(k)?mergeLayer(out.get(k),L):L); }
  return [...out.values()];
}

let suppressNextRemoteApply = false;

const syncToServerDebounced = debounce(async function(){
  if(!currentRoomCode) return;
  const state = shallowSerializableState();
  try{
    suppressNextRemoteApply = true;
    await upsertRoomState(currentRoomCode, state);
    localSaveOnly();
  }catch(e){
    console.warn('Supabase sync failed:', e);
  }finally{
    setTimeout(()=>{ suppressNextRemoteApply=false; }, 250);
  }
}, 350);

function saveState(){ syncToServerDebounced(); }

let roomChannel = null;
function subscribeRoom(code){
  try{
    if(roomChannel){ roomChannel.unsubscribe(); roomChannel=null; }
    roomChannel = supabase.channel('rooms-'+code)
      .on('postgres_changes',
        { event:'*', schema:'public', table:'rooms', filter:'code=eq.'+code },
        async payload=>{
          try{
            const row = payload.new || payload.record;
            if(!row) return;
            if(row.updated_by === clientId) return;
            if(suppressNextRemoteApply) return;
            await applyStateArray(row.state || []);
            localSaveOnly();
          }catch(e){ console.error('Apply remote state failed', e); }
        })
      .subscribe(()=>{});
  }catch(e){ console.error('subscribeRoom guard:', e); }
}

async function joinRoom(code){
  currentRoomCode = code;
  try{
    const existing = await fetchRoom(code);
    if(existing && existing.state && existing.state.length){
      await applyStateArray(existing.state);
    }else{
      clearAllLayers();
      let seeded=false;
      try { await loadKMZFromUrl(encodeURI(PRELOAD_GEOHASHES), 'Geohashes'); seeded=true; } catch(e){ console.warn('Preload geohashes failed', e); }
      for (const name of PRELOAD_COINS){
        try { await loadKMZFromUrl(encodeURI(name)); console.log('Preloaded', name); break; }
        catch(e){ console.warn('Preload failed for', name); }
      }
      await upsertRoomState(code, shallowSerializableState());
    }
    subscribeRoom(code);
  }catch(e){
    console.error('Join failed', e);
    throw e;
  }
}

/* ===== Server Modal helpers ===== */
const modal = document.getElementById('server-modal');
const serverInput = document.getElementById('server-code-input');
const serverJoin = document.getElementById('server-code-join');
const serverErr = document.getElementById('server-error');
function showServerModal(){ modal.classList.add('visible'); appEl.classList.add('blocked-by-modal'); }
function hideServerModal(){ modal.classList.remove('visible'); appEl.classList.remove('blocked-by-modal'); }

serverJoin.addEventListener('click', async ()=>{
  const code = (serverInput.value||'').trim();
  if(!code){ serverErr.textContent='Please enter a server code.'; serverErr.style.display='block'; return; }
  serverErr.style.display='none';
  serverJoin.disabled=true; serverJoin.textContent='Joining...';
  try{
    await joinRoom(code);
    hideServerModal();
  }catch(e){
    console.error('Join failed', e);
    serverErr.textContent='Join failed: '+(e?.message||'Check connection / DNS / RLS / table.');
    serverErr.style.display='block';
  }finally{
    serverJoin.disabled=false; serverJoin.textContent='Join';
  }
});
document.getElementById('server-continue').addEventListener('click', ()=>{
  hideServerModal();
  try{ const raw=localStorage.getItem(LS_KEY); if(raw) applyStateArray(JSON.parse(raw)); }catch{}
});

/* ====================== AUDIO + SFX ====================== */
let audioEnabled = true;
const bgm = new Audio('Evening Traveler - Road Trip.mp3'); bgm.volume = 0.30; bgm.loop = true;
// Pause music when tab hidden
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) bgm.pause(); else if(audioEnabled) bgm.play().catch(()=>{}); });

// WebAudio for instant button sound (eager decode)
let audioCtx = null, buttonBuffer = null;
const btnFallbackAudio = new Audio('button.mp3'); btnFallbackAudio.preload = 'auto';

(async ()=>{
  try{
    const res = await fetch('button.mp3', { cache:'force-cache' });
    const ab = await res.arrayBuffer();
    audioCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    // decodeAudioData promise form (try/catch for Safari older)
    try {
      buttonBuffer = await new Promise((resolve,reject)=>{
        // Safari sometimes needs callback form:
        const p = audioCtx.decodeAudioData(ab.slice(0), resolve, reject);
        if (p && typeof p.then === 'function') p.then(resolve).catch(reject);
      });
    } catch {
      audioCtx.decodeAudioData(ab.slice(0), buf=>buttonBuffer=buf, ()=>{});
    }
  }catch(e){ console.warn('button.mp3 preload failed', e); }
})();

function ensureAudioCtxResumed(){
  try{ if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }catch{}
}
function playClick(){
  try{
    if(!audioEnabled) return;
    ensureAudioCtxResumed();
    if(buttonBuffer && audioCtx){
      const src = audioCtx.createBufferSource(); src.buffer = buttonBuffer; src.connect(audioCtx.destination); src.start(0);
    }else{
      // Fallback: HTMLAudio (still instant thanks to preload)
      btnFallbackAudio.currentTime = 0;
      btnFallbackAudio.play().catch(()=>{});
    }
  }catch(e){ /* swallow */ }
}
// Unlock audio on first interaction
document.addEventListener('pointerdown', ()=>{
  ensureAudioCtxResumed();
  if(audioEnabled && !document.hidden){ bgm.play().catch(()=>{}); }
  playClick(); // primes
},{once:true,capture:true});

// Audio toggle button
const audioBtn = document.getElementById('audio-toggle');
function setAudioIcon(on){
  audioBtn.innerHTML = on
    ? `<svg viewBox="0 0 24 24" fill="none" stroke="#e5e7eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>`
    : `<svg viewBox="0 0 24 24" fill="none" stroke="#e5e7eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="1" x2="1" y2="23"></line></svg>`;
}
setAudioIcon(true);
audioBtn.addEventListener('click', ()=>{
  audioEnabled = !audioEnabled;
  setAudioIcon(audioEnabled);
  if(!audioEnabled) bgm.pause(); else if(!document.hidden) bgm.play().catch(()=>{});
});
// Global click sfx for buttons
document.addEventListener('click', (ev)=>{ if(ev.target.closest('button')) playClick(); }, {capture:true});

/* Sonar sound */
const sonarSfx = new Audio('sonar-sound.mp3');

/* ====================== GPS CONTROLS ====================== */
const geolocate = new maptilersdk.GeolocateControl({
  positionOptions: { enableHighAccuracy: true },
  trackUserLocation: true,
  showUserHeading: true
});
mapgl.addControl(geolocate, 'top-right');

let lastUserPos = null; // [lng, lat]
const sonarBtn = byId('sonar-btn');
function updateSonarEnabled(){
  if(lastUserPos){ sonarBtn.classList.remove('disabled'); sonarBtn.title='Activate Coin Sonar'; }
  else { sonarBtn.classList.add('disabled'); sonarBtn.title='Turn on GPS to use Sonar'; }
}
function onFix(e){
  const lng = e?.coords?.longitude ?? e?.lng ?? e?.lngLat?.lng;
  const lat = e?.coords?.latitude  ?? e?.lat ?? e?.lngLat?.lat;
  if (typeof lng==='number' && typeof lat==='number'){
    lastUserPos=[lng,lat]; updateSonarEnabled();
  }
}
geolocate.on('geolocate', onFix);
mapgl.on('geolocate', onFix);

/* Custom control group: Blue GPS + Edit toggle (placed BELOW zoom/compass) */
function addCustomControls(){
  if (document.querySelector('.custom-ctrl-group')) return;
  const host = mapgl.getContainer().querySelector('.maplibregl-ctrl-top-right') || mapgl.getContainer();
  const wrap = document.createElement('div'); wrap.className='maplibregl-ctrl maplibregl-ctrl-group custom-ctrl-group';

  const gpsBtn  = document.createElement('button'); gpsBtn.className='ctrl-btn blue'; gpsBtn.title='Use device GPS';
  const gpsImg = document.createElement('img'); gpsImg.src='gps-on.png'; gpsImg.alt='GPS';
  gpsBtn.appendChild(gpsImg);
  gpsBtn.addEventListener('click', ()=>{ startBrowserWatch(true); try{ geolocate.trigger(); }catch{} });

  const editBtn = document.createElement('button'); editBtn.className='ctrl-btn edit'; editBtn.title='Toggle Edit Mode';
  editBtn.innerHTML = `<svg viewBox="0 0 24 24" width="18" height="18" fill="#1f2937"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04 18.37 4.7a1 1 0 0 0-1.42 0L14.13 4.1l3.75 3.75z"/></svg>`;
  editBtn.addEventListener('click', ()=>{ editingEnabled = !editingEnabled; editBtn.classList.toggle('active', editingEnabled); if(!editingEnabled) closeStyleEditor(); });

  wrap.append(gpsBtn, editBtn);
  // Append (not prepend) so it sits below the default controls
  host.appendChild(wrap);
}
mapgl.on('load', addCustomControls);
setTimeout(addCustomControls, 2000);  // fallback

/* Browser-level watchPosition */
let geoWatchId = null;
function startBrowserWatch(forceOneShot=false){
  if(!('geolocation' in navigator)) return;
  if(geoWatchId===null){
    geoWatchId = navigator.geolocation.watchPosition(
      pos=>{ lastUserPos=[pos.coords.longitude,pos.coords.latitude]; updateSonarEnabled(); },
      err=>{ console.warn('watchPosition error:', err); },
      { enableHighAccuracy:true, maximumAge:5000, timeout:10000 }
    );
  }
  if(forceOneShot){
    navigator.geolocation.getCurrentPosition(
      pos=>{ lastUserPos=[pos.coords.longitude,pos.coords.latitude]; updateSonarEnabled(); },
      ()=>{}, { enableHighAccuracy:true, maximumAge:5000, timeout:5000 }
    );
  }
}
startBrowserWatch();

/* ===== Sonar UI ===== */
const sonarModal = byId('sonar-modal');
const radiusSeg = byId('sonar-radius');
const colorSeg  = byId('sonar-color');
const scanNow   = byId('scan-now');
const scanWait  = byId('scan-wait');

let sonarRadius = 50;
let sonarColor  = 'red';

function openSonar(){ sonarModal.classList.add('visible'); appEl.classList.add('blocked-by-modal'); }
function closeSonar(){ sonarModal.classList.remove('visible'); appEl.classList.remove('blocked-by-modal'); scanWait.classList.remove('visible'); }
sonarBtn.addEventListener('click', ()=>{ if(!lastUserPos){ alert('Please enable GPS first.'); return; } openSonar(); });
sonarModal.addEventListener('click', (e)=>{ if(e.target === sonarModal) closeSonar(); });
function setActiveChip(container, chip){ container.querySelectorAll('.chip').forEach(c=>c.classList.remove('active')); chip.classList.add('active'); }
radiusSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('.chip'); if(!btn) return; sonarRadius=parseInt(btn.dataset.radius,10)||50; setActiveChip(radiusSeg,btn); });
colorSeg.addEventListener('click', (e)=>{ const btn=e.target.closest('.chip'); if(!btn) return; sonarColor=(btn.dataset.color==='green')?'green':'red'; setActiveChip(colorSeg,btn); });

/* ===== Geometry helpers ===== */
const sin=Math.sin, cos=Math.cos, asin=Math.asin, atan2=Math.atan2, PI=Math.PI;
function circleGeoJSON(lng, lat, radiusMeters, steps=96){
  const coords=[], R=6378137, d=radiusMeters/R, latRad=lat*PI/180, lngRad=lng*PI/180;
  for(let i=0;i<=steps;i++){
    const brng=(i/steps)*2*PI;
    const lat2=asin(sin(latRad)*cos(d)+cos(latRad)*sin(d)*cos(brng));
    const lng2=lngRad+atan2(sin(brng)*sin(d)*cos(latRad),cos(d)-sin(lat2));
    coords.push([lng2*180/PI, lat2*180/PI]);
  }
  return {type:'Polygon',coordinates:[coords]};
}

/* ===== Sonar layer management (unchanged) ===== */
function getOrCreateSonarLayer(){
  return getOrCreateLayerByName('Coin Sonar Scans');
}
function addSonarCircle(centerLngLat, radius, color){
  const entry = getOrCreateSonarLayer();
  const fid = `sonar-${clientId}-${Date.now()}-${Math.floor(Math.random()*1e6)}`;
  const hex = (color==='green') ? '#22c55e' : '#ef4444';
  const geom = circleGeoJSON(centerLngLat[0], centerLngLat[1], radius, 96);
  const name = `Sonar ${radius}m (${color.toUpperCase()}) @ ${new Date().toLocaleString()}`;
  const props = { fid, name, hidden:false, _gid:fid, _ts:Date.now(), _fill:hex, _fillOpacity:0.18, _stroke:hex, _strokeOpacity:0.9, _weight:2 };
  entry.data.features.push({ type:'Feature', geometry:geom, properties:props });
  entry.items.push({ fid, name, label:'•', visible:true });
  refreshGroupBoth(entry); renderLayers(); renderGroupsVisibility(); saveState();
  const b=bboxOfFeature({geometry:geom});
  if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:500}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]});
}
scanNow.addEventListener('click', async ()=>{
  if(!lastUserPos){ alert('GPS not ready.'); return; }
  try{ sonarSfx.currentTime=0; if(audioEnabled) sonarSfx.play(); }catch{}
  scanWait.classList.add('visible'); scanNow.disabled=true;
  await new Promise(r=>setTimeout(r, 1000));
  addSonarCircle(lastUserPos, sonarRadius, sonarColor);
  scanNow.disabled=false; scanWait.classList.remove('visible'); closeSonar();
});

/* ================= Startup ================= */
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const urlParams = new URLSearchParams(location.search);
    const preCode = urlParams.get('server') || '';
    if(preCode){ serverInput.value = preCode; }
  }catch(e){ console.error('Startup guard:', e); }
  updateSonarEnabled();
});

/* ================= Export KML / KMZ ================= */
function escapeXml(s){return String(s).replace(/[<>&'"]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;' }[c]));}
function kmlColorFromCss(hex,opacity){ const h=(hex||'#0b57d0').replace('#',''); const r=parseInt(h.slice(0,2),16)||0, g=parseInt(h.slice(2,4),16)||0, b=parseInt(h.slice(4,6),16)||0; const a=Math.round((opacity==null?1:opacity)*255); const to2=x=>x.toString(16).padStart(2,'0'); return to2(a)+to2(b)+to2(g)+to2(r); }
function serializePlacemark(f){
  const p=f.properties||{}, name=escapeXml(p.name||'Feature'), styleId='s'+(p.fid||'x');
  if(p._deleted) return '';
  let geomStr='';
  if(f.geometry.type==='Point'){ const [lng,lat]=f.geometry.coordinates; geomStr=`<Point><coordinates>${lng},${lat},0</coordinates></Point>`; }
  else if(f.geometry.type==='LineString'){ geomStr=`<LineString><coordinates>${f.geometry.coordinates.map(c=>c.join(',')).join(' ')}</coordinates></LineString>`; }
  else if(f.geometry.type==='Polygon'){
    const rings=f.geometry.coordinates.map((ring,i)=>`<${i===0?'outerBoundaryIs':'innerBoundaryIs'}><LinearRing><coordinates>${ring.map(c=>c.join(',')).join(' ')}</coordinates></LinearRing></${i===0?'outerBoundaryIs':'innerBoundaryIs'}>`).join('');
    geomStr=`<Polygon>${rings}</Polygon>`;
  } else return '';
  const style = `
    <Style id="${styleId}">
      <IconStyle>${p._iconUrl?`<Icon><href>${escapeXml(p._iconUrl)}</href></Icon>`:''}</IconStyle>
      <LineStyle><color>${kmlColorFromCss(p._stroke, p._strokeOpacity)}</color><width>${p._weight||2}</width></LineStyle>
      <PolyStyle><color>${kmlColorFromCss(p._fill, p._fillOpacity)}</color></PolyStyle>
    </Style>`;
  return style + `<Placemark><name>${name}</name><styleUrl>#${styleId}</styleUrl>${geomStr}${p.description?`<description><![CDATA[${p.description}]]></description>`:''}</Placemark>`;
}
function exportKMLString(){
  const body=layerList.map(l=>`<Folder><name>${escapeXml(l.name)}</name>${l.data.features.filter(f=>!f.properties.hidden && !f.properties._deleted).map(serializePlacemark).join('')}</Folder>`).join('');
  return `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>${body}</Document></kml>`;
}
function downloadBlob(name, blob){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }
byId('export-kml').onclick=()=>{ const kml=exportKMLString(); downloadBlob('sqkii-export.kml', new Blob([kml],{type:'application/vnd.google-earth.kml+xml'})); };
byId('export-kmz').onclick=async()=>{ const zip=new JSZip(); const kml=exportKMLString(); zip.file('doc.kml', kml); const blob=await zip.generateAsync({type:'blob'}); downloadBlob('sqkii-export.kmz', blob); };
</script>
</body>
</html>
