<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MyMaps-like Editor (MapTiler + Leaflet, dark)</title>

  <!-- MapTiler SDK (MapLibre) -->
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.umd.min.js"></script>
  <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.css" rel="stylesheet" />

  <!-- Leaflet (for OSM raster) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- togeojson + jszip -->
  <script src="https://unpkg.com/@tmcw/togeojson@4.7.0/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    :root{
      /* ---- DARK THEME ---- */
      --panel:#0f1115;       /* sidebar bg */
      --panel-2:#12151b;     /* cards/rows */
      --muted:#98a2b3;       /* secondary text */
      --text:#e5e7eb;        /* primary text */
      --accent:#60a5fa;      /* link/accent */
      --border:#1f2430;      /* lines */
      --bg:#0b0d11;          /* app bg */
      --chip:#1c212e;
      --side:380px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    .app{position:relative;display:grid;grid-template-columns: var(--side) 1fr;height:100vh;transition:grid-template-columns .28s ease;}
    .ui-reopen{position:absolute;right:10px;top:10px;z-index:1100;display:none;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    .app.ui-collapsed .ui-reopen{display:inline-block;}
    .sidebar{position:relative;background:var(--panel);border-right:1px solid var(--border);overflow:auto;width:var(--side);transition:width .28s ease;}
    .header{padding:12px;border-bottom:1px solid var(--border);}
    .project-title{font-weight:800;font-size:16px;}
    .toolbar{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;}
    .btn{background:var(--chip);border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-weight:600;cursor:pointer;color:var(--text);}
    .btn.small{padding:4px 8px;font-size:12px;}
    .hint{color:var(--muted);font-size:12px;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
    input[type="url"],select{
      width:100%;box-sizing:border-box;border:1px solid var(--border);border-radius:8px;padding:8px 10px;
      background:var(--panel-2);color:var(--text);
    }
    #mapgl, #mapleaf{height:100%;width:100%;}
    .dropzone{
      border:2px dashed var(--border);border-radius:12px;margin:12px;padding:14px;text-align:center;color:var(--muted);
      background:var(--panel-2);
    }
    .dropzone.dragover{border-color:var(--accent);color:var(--accent);background:#0e1729;}

    .layers-empty{padding:14px;}
    .layer{border-bottom:1px solid var(--border);background:var(--panel-2);}
    .layer+.layer{margin-top:10px;border-radius:10px;overflow:hidden;}
    .layer-head{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:10px 12px;}
    .layer-head .title{font-weight:700;}
    .layer-head .note{font-size:12px;color:var(--muted);}
    .import-line{padding:8px 12px;background:#0e1420;border-top:1px solid var(--border);}
    .import-line .link{color:var(--accent);font-weight:600;cursor:pointer;}
    .feature{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px 12px;border-top:1px solid var(--border);}
    .feature .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .group-bullet{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;border:1px solid #2a3243;background:#11161f;color:#fff;font-size:12px;font-weight:800;}
    .toggle{display:inline-grid;place-items:center;width:16px;height:16px;border:1px solid #2a3243;border-radius:4px;background:#0f141d;cursor:pointer;}
    .toggle.checked{background:#16a34a;border-color:#16a34a;}
    details.grp {margin:10px 12px;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);}
    details.grp > summary {list-style:none;padding:10px 12px;cursor:pointer;font-weight:700;}
    details.grp > summary::-webkit-details-marker{display:none;}
    .grp-list{padding:8px 12px;display:grid;gap:6px;max-height:220px;overflow:auto;}

    .yt-portrait{width:240px;aspect-ratio:9/16;background:#000;border-radius:12px;overflow:hidden;margin:0 0 8px 0;}
    @media (min-width:480px){ .yt-portrait{ width:260px; } }
    .yt-portrait > iframe{width:100%;height:100%;display:block;border:0}

    .ui-hide{position:absolute; top:10px; right:10px; z-index:1001;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    a{color:var(--accent);}

    /* ---- DARK POPUPS (MapLibre + Leaflet) ---- */
    .maplibregl-popup-content{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .maplibregl-popup-tip{border-top-color:#0f1115 !important;border-bottom-color:#0f1115 !important;border-left-color:#0f1115 !important;border-right-color:#0f1115 !important;}
    .leaflet-popup-content-wrapper{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .leaflet-popup-tip{background:#0f1115;}
  </style>
</head>
<body>
<div class="app" id="app">
  <button id="ui-reopen" class="ui-reopen" title="Open UI">Open UI</button>

  <aside class="sidebar" id="sidebar">
    <button id="ui-hide" class="ui-hide" title="Hide UI">Hide UI</button>

    <div class="header">
      <div class="project-title">SQKII MAPPER</div>
      <div class="toolbar">
        <button class="btn small" id="upload-btn">Upload files</button>
        <input id="upload-input" type="file" accept=".kml,.kmz" multiple style="display:none" />
        <button class="btn small" id="add-layer">Add layer</button>
        <button class="btn small" id="share">Share</button>
        <button class="btn small" id="preview">Preview</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="url-input" type="url" placeholder="https://example.com/map.kml or .kmz" />
        <button class="btn small" id="url-load">Load URL</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <div class="hint" style="margin-bottom:4px;">Map style</div>
          <select id="basemap">
            <option value="custom" selected>Custom (your MapTiler style)</option>
            <option value="streets">MapTiler Streets</option>
            <option value="osm">OpenStreetMap (raster)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="hint" style="margin-top:6px;">Dark UI · Last edit just now</div>
    </div>

    <div class="dropzone" id="dz">
      <div><strong>Drop KML/KMZ here</strong></div>
      <div class="hint">…or use the Upload button above</div>
    </div>

    <details class="grp" id="group-visibility" open>
      <summary>Groups visibility</summary>
      <div class="grp-list" id="grp-list"></div>
    </details>

    <div id="layers"></div>
  </aside>

  <!-- Two engines: MapLibre/MapTiler and Leaflet/OSM -->
  <main id="mapgl"></main>
  <main id="mapleaf" style="display:none"></main>
</div>

<script>
/* ================= Map engines ================= */
maptilersdk.config.apiKey = 'f9B8Wv0ythtbvpcK0QEw';
const CUSTOM_STYLE = 'https://api.maptiler.com/maps/01994e5b-af91-7fae-b8bd-a68c497abf96/style.json?key=' + maptilersdk.config.apiKey;

const mapgl = new maptilersdk.Map({
  container: 'mapgl',
  style: CUSTOM_STYLE,
  center: [103.8198, 1.3521],
  zoom: 12
});
function glReady(fn){ if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) fn(); else mapgl.once('load', fn); }

const mapleaf = L.map('mapleaf', { zoomControl: true, attributionControl: true }).setView([1.3521,103.8198], 12);
const osmTiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom: 19, attribution:'&copy; OpenStreetMap contributors'});
osmTiles.addTo(mapleaf);

// engine switching
let engine = 'gl';
function showGL(){
  // sync from leaflet
  const c = mapleaf.getCenter(); const z = mapleaf.getZoom();
  document.getElementById('mapleaf').style.display = 'none';
  document.getElementById('mapgl').style.display = 'block';
  mapgl.resize();
  mapgl.jumpTo({center:[c.lng, c.lat], zoom: z});
  engine = 'gl';
}
function showLeaf(){
  // sync from gl
  const c = mapgl.getCenter(); const z = mapgl.getZoom();
  document.getElementById('mapgl').style.display = 'none';
  document.getElementById('mapleaf').style.display = 'block';
  mapleaf.invalidateSize(true);
  mapleaf.setView([c.lat, c.lng], Math.round(z));
  engine = 'leaf';
}

/* ================= Icon registry for MapLibre ================= */
const DOLLAR_ICON_NAME = 'dollar-pin';
let iconSeq = 1;
const urlToName = new Map(); // url -> name
const nameToUrl = new Map(); // name -> url

function dollarSvg(size){
  const s=size||64;
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 32 32">
    <circle cx="16" cy="16" r="13" fill="#111" stroke="white" stroke-width="1.5"/>
    <text x="16" y="21" text-anchor="middle" font-family="system-ui,Segoe UI,Arial" font-size="16" font-weight="800" fill="white">$</text>
  </svg>`;
}
function addImageToGL(name, urlOrData){
  return new Promise(res=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.referrerPolicy = 'no-referrer';
    img.onload = ()=>{ try{ mapgl.addImage(name, img, { pixelRatio: 2 }); }catch(_){} res(); };
    img.onerror = ()=>res();
    img.src = urlOrData;
  });
}
async function ensureDollarIcon(){ if (mapgl.hasImage && mapgl.hasImage(DOLLAR_ICON_NAME)) return; await addImageToGL(DOLLAR_ICON_NAME, 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(64))); }
function registerIconUrl(url){
  if (!url) return DOLLAR_ICON_NAME;
  if (urlToName.has(url)) return urlToName.get(url);
  const name = 'icon-' + (iconSeq++);
  urlToName.set(url, name); nameToUrl.set(name, url);
  if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) addImageToGL(name, url);
  else mapgl.once('load', ()=> addImageToGL(name, url));
  return name;
}
async function ensureAllIconsOnCurrentStyle(){
  await ensureDollarIcon();
  for (const [url, name] of urlToName.entries()){
    if (!mapgl.hasImage(name)) await addImageToGL(name, url);
  }
}
mapgl.on('styleimagemissing', (e)=>{ const url = nameToUrl.get(e.id); if (url) addImageToGL(e.id, url); });

/* After GL style swap, re-add overlays */
function readdAllGroupsAfterGLStyleChange(){
  let done=false;
  function hydrate(){ if(done) return; done=true; (async()=>{
    await ensureAllIconsOnCurrentStyle();
    layerList.forEach(e=>{ createGroupOnGL(e,true); if(e.visible===false && e.glLayerIds){ e.glLayerIds.forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility','none');}); }});
    renderLayers(); renderGroupsVisibility();
  })();}
  mapgl.once('load', hydrate); mapgl.once('idle', hydrate);
}

/* ================= App state / utils ================= */
let layerSeq=1, featureSeq=1;
const layerList=[]; // {id,name,visible,data:FC,items:[], glSourceId, glLayerIds[], lfGroup, lfLayers: Map(fid -> L.Layer[])}

const byId = (id)=>document.getElementById(id);

function kmlColorToCss(aabbggrr){ if(!aabbggrr){return {hex:'#000000', opacity:1};} let s=aabbggrr.trim(); if(s.length===6) s='ff'+s; return {hex:'#'+s.slice(6,8)+s.slice(4,6)+s.slice(2,4), opacity:parseInt(s.slice(0,2),16)/255}; }
function defaultLabelFrom(name){ if(!name) return '•'; const c=(name.trim()[0]||'•').toUpperCase(); return /[A-Z0-9$]/.test(c)?c:'•'; }
function escapeHtml(s){return (s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));}
function sanitizeHtml(input){
  try{
    const parser=new DOMParser(); const doc=parser.parseFromString('<div>'+input+'</div>','text/html');
    const allowedTags={A:1,B:1,I:1,EM:1,STRONG:1,P:1,BR:1,UL:1,OL:1,LI:1,IMG:1,DIV:1,SPAN:1};
    const allowedAttrs={A:['href','title'], IMG:['src','alt','width','height','loading']};
    (function clean(node){
      for(const el of [...node.childNodes]){
        if(el.nodeType===1){
          if(!allowedTags[el.tagName]){ while(el.firstChild) node.insertBefore(el.firstChild,el); node.removeChild(el); continue; }
          for(const a of [...el.attributes]){
            const ok=(allowedAttrs[el.tagName]||[]);
            if(!ok.includes(a.name.toLowerCase())) el.removeAttribute(a.name);
          }
          if(el.tagName==='A'){
            const href=el.getAttribute('href')||'';
            el.setAttribute('target','_blank'); el.setAttribute('rel','noopener');
            if(/^javascript:/i.test(href)) el.removeAttribute('href');
          }
          if(el.tagName==='IMG'){ el.setAttribute('loading','lazy'); }
          clean(el);
        }
      }
    })(doc.body);
    return doc.body.firstChild.innerHTML;
  }catch(e){ return ''; }
}
function findYouTubeId(str){ if(!str) return ''; const m=String(str).match(/(?:youtube\.com\/watch\?[^#\s]*v=|youtu\.be\/|youtube\.com\/embed\/)([A-Za-z0-9_-]{11})/); return m?m[1]:''; }
function buildYouTubeEmbed(id){ if(!id) return ''; const src='https://www.youtube-nocookie.com/embed/'+id+'?rel=0&modestbranding=1&playsinline=1'; return '<div class="yt-portrait"><iframe src="'+src+'" title="YouTube" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>'; }
function buildPopupHTMLFromProps(props){
  const name = props.name || 'Feature';
  const rawDesc = props.description || '';
  const looksHtml = /<\/?[a-z][\s\S]*>/i.test(rawDesc);
  let safeHtml = looksHtml ? sanitizeHtml(rawDesc) : escapeHtml(rawDesc).replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" rel="noopener">$1</a>');
  // strip thumbnails
  const tmp=document.createElement('div'); tmp.innerHTML=safeHtml; tmp.querySelectorAll('img').forEach(img=>img.remove()); safeHtml = tmp.innerHTML;
  const id = findYouTubeId(rawDesc) || findYouTubeId(tmp.textContent||'');
  const embed = buildYouTubeEmbed(id);
  return '<div style="min-width:260px;max-width:340px;">'
       + '<div style="font-weight:800;font-size:16px;margin-bottom:6px;">'+escapeHtml(name)+'</div>'
       + (embed || '')
       + (safeHtml ? '<div style="font-size:13px;line-height:1.35;color:#cbd5e1;">'+safeHtml+'</div>' : '')
       + '</div>';
}
function bboxOfFeature(f){
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  (function scan(c){ if(typeof c[0]==='number'){ const [x,y]=c; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);} else c.forEach(scan); })(f.geometry.coordinates);
  return [[minX,minY],[maxX,maxY]];
}
function panPopupIntoViewGL(lngLat, liftPx = 180){
  const p = mapgl.project(lngLat); p.y -= liftPx; const center = mapgl.unproject(p); mapgl.easeTo({ center, duration: 350 });
}

/* ================= KMZ assets + KML parsing ================= */
async function buildKmzAssetMap(zip){
  const out={};
  for (const f of Object.values(zip.files)){
    if(!f.dir && /\.(png|jpe?g|gif|svg)$/i.test(f.name)){
      out[f.name]=URL.createObjectURL(await f.async('blob'));
    }
  }
  return out;
}
function resolveIconHref(href, opts){
  if(!href) return '';
  if(/^(https?:|data:|blob:)/i.test(href)) return href;
  if(opts && opts.assetMap){
    if(opts.assetMap[href]) return opts.assetMap[href];
    const base=href.split(/[\\/]/).pop();
    for(const k of Object.keys(opts.assetMap)){
      if(k===base || k.endsWith('/'+base)) return opts.assetMap[k];
    }
  }
  if(opts && opts.baseUrl){ try{return new URL(href,opts.baseUrl).href;}catch(e){} }
  return href;
}
function extractKmlMeta(xmlDoc, opts){
  function t(n,sel){ const el=n.querySelector(sel); return el ? (el.textContent||'').trim():''; }
  const styleById={}, smById={};
  xmlDoc.querySelectorAll('Style[id], style[id]').forEach(s=>styleById[s.getAttribute('id')]=s);
  xmlDoc.querySelectorAll('StyleMap[id], styleMap[id]').forEach(s=>smById[s.getAttribute('id')]=s);
  function resolveStyleUrl(url){
    if(!url) return null;
    const id=url.replace(/^#/,''); const sm=smById[id];
    if(sm){ for(const p of sm.querySelectorAll('Pair')) if((t(p,'key')||'').toLowerCase()==='normal'){ const su=t(p,'styleUrl'); if(su) return resolveStyleUrl(su); } }
    return styleById[id]||null;
  }
  function topFolderName(node){
    let cur=node.parentNode, top='';
    while(cur && cur.nodeType===1){ if(/Folder/i.test(cur.tagName)){ const nm=t(cur,'name'); if(nm) top=nm; } cur=cur.parentNode; }
    return top || 'Untitled layer';
  }
  function parseStyle(styleEl){
    if(!styleEl) return {};
    const iconHref = t(styleEl,'IconStyle Icon href') || t(styleEl,'iconStyle icon href');
    const lineColor= t(styleEl,'LineStyle color') || t(styleEl,'lineStyle color');
    const lineWidth= t(styleEl,'LineStyle width') || t(styleEl,'lineStyle width');
    const polyColor= t(styleEl,'PolyStyle color') || t(styleEl,'polyStyle color');
    return { iconHref: resolveIconHref(iconHref, opts), lineColor, lineWidth, polyColor };
  }
  const metas=[];
  xmlDoc.querySelectorAll('Placemark, placemark').forEach(pm=>{
    const sEl = resolveStyleUrl(t(pm,'styleUrl'));
    metas.push({ name:t(pm,'name'), topFolder:topFolderName(pm), style:parseStyle(sEl) });
  });
  return metas;
}

/* ================= MapLibre overlay ================= */
function createGroupOnGL(entry, clearIfExists){
  glReady(async ()=> {
    await ensureAllIconsOnCurrentStyle();

    const srcId = 'src-'+entry.id;
    const fillId = 'fill-'+entry.id;
    const lineId = 'line-'+entry.id;
    const iconId = 'icon-'+entry.id;
    const lblId  = 'lbl-'+entry.id;

    entry.glSourceId = srcId;
    entry.glLayerIds = [fillId,lineId,iconId,lblId];

    if (clearIfExists){
      [lblId,iconId,lineId,fillId].forEach(id=>{ if(mapgl.getLayer(id)) try{ mapgl.removeLayer(id); }catch(e){} });
      if (mapgl.getSource(srcId)) try{ mapgl.removeSource(srcId); }catch(e){}
    }

    if (mapgl.getSource(srcId)) mapgl.removeSource(srcId);
    mapgl.addSource(srcId, { type:'geojson', data: entry.data });

    const notHidden = ['!=',['get','hidden'],true];

    mapgl.addLayer({ id: fillId, type:'fill', source: srcId,
      filter: ['all', notHidden, ['in',['geometry-type'],['literal',['Polygon','MultiPolygon']]]],
      paint: { 'fill-color': ['coalesce',['get','_fill'],'#0b57d0'], 'fill-opacity': ['coalesce',['get','_fillOpacity'],0.2] } });

    mapgl.addLayer({ id: lineId, type:'line', source: srcId,
      filter: ['all', notHidden, ['in',['geometry-type'],['literal',['LineString','MultiLineString']]]],
      paint:{ 'line-color': ['coalesce',['get','_stroke'],'#0b57d0'], 'line-width': ['coalesce',['get','_weight'],2], 'line-opacity': ['coalesce',['get','_strokeOpacity'],0.9] } });

    mapgl.addLayer({ id: iconId, type:'symbol', source: srcId,
      filter: ['all', notHidden, ['==',['geometry-type'],'Point']],
      layout:{ 'icon-image': ['coalesce',['get','_icon'], DOLLAR_ICON_NAME], 'icon-size': ['coalesce',['get','_iconSize'], 1], 'icon-anchor':'bottom', 'icon-allow-overlap': true } });

    mapgl.addLayer({ id: lblId, type:'symbol', source: srcId,
      filter: ['all', notHidden, ['==',['geometry-type'],'Point']],
      layout:{ 'text-field': ['coalesce',['get','_label'],''], 'text-font': ['Noto Sans Regular'], 'text-size': 11, 'text-offset': [0, 1.1], 'text-anchor':'top' },
      paint:{ 'text-color':'#e5e7eb', 'text-halo-color':'#0b0d11', 'text-halo-width':1.2 } });

    const POP = 18;
    [fillId,lineId,iconId,lblId].forEach(lid=>{
      mapgl.on('click', lid, (e)=>{
        panPopupIntoViewGL(e.lngLat, 180);
        new maptilersdk.Popup({ anchor:'bottom', offset:[0, POP], maxWidth:'340px', closeOnClick:true })
          .setLngLat(e.lngLat)
          .setHTML(buildPopupHTMLFromProps((e.features[0] && e.features[0].properties) || {}))
          .addTo(mapgl);
      });
      mapgl.on('mouseenter', lid, ()=> mapgl.getCanvas().style.cursor='pointer');
      mapgl.on('mouseleave', lid, ()=> mapgl.getCanvas().style.cursor='');
    });
  });
}
function refreshGroupGL(entry){ const src = mapgl.getSource(entry.glSourceId); if (src) src.setData(entry.data); }

/* ================= Leaflet overlay (for OSM) ================= */
function dollarDataUrl(size=32){ return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(dollarSvg(size)); }
function leafletIconFor(url, size=32){
  return L.icon({
    iconUrl: url || dollarDataUrl(size),
    iconSize: [size,size],
    iconAnchor: [size/2, size-2],
    popupAnchor: [0, -size/2]
  });
}
function createGroupOnLeaflet(entry, rebuild=false){
  if (rebuild && entry.lfGroup){ try{ entry.lfGroup.remove(); }catch(e){} }
  entry.lfGroup = L.layerGroup().addTo(mapleaf);
  entry.lfLayers = new Map();

  entry.data.features.forEach(f=>{
    const fid = f.properties.fid;
    const list = [];

    // geometry styles
    const lineStyle = { color: f.properties._stroke || '#0b57d0', weight: f.properties._weight || 2, opacity: f.properties._strokeOpacity ?? 0.9 };
    const fillStyle = { color: f.properties._stroke || '#0b57d0', weight: f.properties._weight || 2, opacity: f.properties._strokeOpacity ?? 0.9,
                        fillColor: f.properties._fill || '#0b57d0', fillOpacity: f.properties._fillOpacity ?? 0.2 };

    if (f.geometry.type === 'Point'){
      const [lng,lat] = f.geometry.coordinates;
      const icon = leafletIconFor(f.properties._iconUrl || nameToUrl.get(f.properties._icon), 32);
      const m = L.marker([lat,lng], { icon })
        .bindPopup(buildPopupHTMLFromProps(f.properties), { autoPan:true, offset:[0,-18] })
        .on('click', e=> m.openPopup());
      if (!f.properties.hidden) m.addTo(entry.lfGroup);
      list.push(m);
    } else {
      const gj = L.geoJSON(f, {
        style: (geom)=> (geom.type.includes('Polygon') ? fillStyle : lineStyle)
      }).bindPopup(buildPopupHTMLFromProps(f.properties), { autoPan:true, offset:[0,-18] });
      if (!f.properties.hidden) gj.addTo(entry.lfGroup);
      list.push(gj);
    }
    entry.lfLayers.set(fid, list);
  });
}

/* ================= Rendering both engines ================= */
function createGroupBoth(entry){
  createGroupOnGL(entry);
  createGroupOnLeaflet(entry);
}
function refreshGroupBoth(entry){
  refreshGroupGL(entry);
  // Rebuild Leaflet group cheaply: remove/add based on hidden flags
  if (entry.lfGroup && entry.lfLayers){
    entry.lfLayers.forEach((layers, fid)=>{
      const f = entry.data.features.find(x=>x.properties.fid===fid);
      const hidden = f && f.properties.hidden;
      layers.forEach(Lyr=>{
        if (hidden){ try{ entry.lfGroup.removeLayer(Lyr); }catch(e){} }
        else { try{ entry.lfGroup.addLayer(Lyr); }catch(e){} }
      });
    });
  }
}

/* ================= UI: groups & layers ================= */
function renderGroupsVisibility(){
  const host=byId('grp-list'); host.innerHTML='';
  if(!layerList.length){ host.innerHTML='<div class="hint">No groups yet.</div>'; return; }
  for(const entry of layerList){
    const row=document.createElement('div'); row.className='grp-row';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=entry.visible!==false;
    const name=document.createElement('div'); name.textContent=entry.name;
    const count=document.createElement('div'); count.className='hint'; count.textContent=entry.items.length;
    cb.onchange=()=>{
      entry.visible=cb.checked;
      // GL
      (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility', cb.checked?'visible':'none'); });
      // Leaflet
      if (entry.lfGroup){ if(cb.checked) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); }
      renderLayers();
    };
    row.append(cb,name,count); host.appendChild(row);
  }
}
function renderLayers(){
  const host=byId('layers'); host.innerHTML='';
  if(!layerList.length){
    host.innerHTML='<div class="layers-empty"><div class="hint">No layers yet. Upload or drop a KML/KMZ.</div></div>'; return;
  }
  for(const entry of layerList){
    const visibleOnMap = entry.visible!==false;
    const wrap=document.createElement('div'); wrap.className='layer';
    const head=document.createElement('div'); head.className='layer-head';
    const vis=document.createElement('div'); vis.className= visibleOnMap?'toggle checked':'toggle'; vis.title='Show/Hide layer';
    vis.onclick=()=>{
      entry.visible=!visibleOnMap;
      (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility', entry.visible?'visible':'none'); });
      if (entry.lfGroup){ if(entry.visible) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); }
      renderGroupsVisibility(); renderLayers();
    };
    const ttl=document.createElement('div'); ttl.className='title'; ttl.textContent=entry.name;
    const right=document.createElement('div'); right.className='layer-actions';
    const note=document.createElement('div'); note.className='note'; note.textContent = visibleOnMap ? '' : '(hidden)';
    if(note.textContent) right.appendChild(note);
    head.append(vis,ttl,right); wrap.appendChild(head);

    if(visibleOnMap){
      const importLine=document.createElement('div'); importLine.className='import-line';
      const link=document.createElement('span'); link.className='link'; link.textContent='Import';
      link.onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.kml,.kmz';
        inp.onchange=ev=>{ const f=ev.target.files[0]; if(!f) return; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f, entry.name); else f.text().then(txt=>addKmlText(txt,f.name,{}, entry.name)); };
        inp.click();
      };
      importLine.appendChild(link); wrap.appendChild(importLine);

      for(const it of entry.items){
        const row=document.createElement('div'); row.className='feature';
        const ico=document.createElement('div'); ico.className='group-bullet'; ico.textContent='$';
        const name=document.createElement('div'); name.className='name'; name.textContent=it.name; name.onclick=()=> zoomToFeature(entry, it.fid);
        const togg=document.createElement('div'); togg.className=it.visible!==false?'toggle checked':'toggle';
        togg.onclick=()=>{
          it.visible = !(it.visible!==false);
          const gf = entry.data.features.find(f=>f.properties.fid===it.fid);
          if(gf){ gf.properties.hidden = it.visible===false; refreshGroupBoth(entry); }
          togg.className = it.visible!==false ? 'toggle checked' : 'toggle';
        };
        row.append(ico,name,togg); wrap.appendChild(row);
      }
    }
    host.appendChild(wrap);
  }
}
function zoomToFeature(entry, fid){
  const f = entry.data.features.find(x=>x.properties && x.properties.fid===fid); if(!f) return;
  const b=bboxOfFeature(f);
  if (engine==='gl') mapgl.fitBounds(b, {padding:40, duration:600});
  else mapleaf.fitBounds([[b[0][1], b[0][0]],[b[1][1], b[1][0]]], {padding:[40,40]});
}

/* ================= Loaders ================= */
async function loadKMZFile(file, forceGroupName){
  try{
    const zip=await JSZip.loadAsync(file);
    const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml'));
    if(!kmlEntry){ alert('No .kml found inside KMZ: '+file.name); return; }
    const assetMap = await buildKmzAssetMap(zip);
    const text=await kmlEntry.async('text');
    addKmlText(text,file.name,{assetMap}, forceGroupName);
  }catch(e){ console.error(e); alert('Failed to read KMZ: '+file.name); }
}
async function loadKMLFromUrl(url, forceGroupName){
  const res=await fetch(url); if(!res.ok) throw new Error('HTTP ' + res.status);
  const text=await res.text(); addKmlText(text, url.split('/').pop()||'remote.kml', {baseUrl:url}, forceGroupName);
}
async function loadKMZFromUrl(url, forceGroupName){
  const res=await fetch(url); if(!res.ok) throw new Error('HTTP ' + res.status);
  const blob=await res.blob();
  const zip=await JSZip.loadAsync(blob);
  const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml'));
  if(!kmlEntry) throw new Error('No .kml inside KMZ');
  const assetMap = await buildKmzAssetMap(zip);
  const text=await kmlEntry.async('text');
  addKmlText(text, url.split('/').pop()||'remote.kmz', {assetMap, baseUrl:url}, forceGroupName);
}

function addKmlText(text, filename, opts, forceGroupName){
  const xml=new DOMParser().parseFromString(text,'text/xml');
  const metaList=extractKmlMeta(xml, opts||{});
  const gj=window.toGeoJSON.kml(xml);
  if(!gj || !gj.features || !gj.features.length){ alert('No features in '+filename); return; }

  const grouped={}; metaList.forEach((m,i)=>{ const f=forceGroupName || m.topFolder || 'Untitled layer'; (grouped[f]||(grouped[f]=[])).push(i); });

  for(const gname of Object.keys(grouped)){
    const features=[], items=[];
    for(const idx of grouped[gname]){
      const f=gj.features[idx], m=metaList[idx], fid=featureSeq++;
      const props = f.properties||{};
      const itemName = m.name || props.name || props.Name || props.title || ('Feature '+fid);

      const style = {};
      if(m.style.lineColor){ const lc=kmlColorToCss(m.style.lineColor); style._stroke=lc.hex; style._strokeOpacity=lc.opacity; }
      if(m.style.lineWidth){ const w=parseFloat(m.style.lineWidth); if(!isNaN(w)) style._weight=w; }
      if(m.style.polyColor){ const pc=kmlColorToCss(m.style.polyColor); style._fill=pc.hex; style._fillOpacity=pc.opacity; }

      let iconName = DOLLAR_ICON_NAME, iconUrl = '';
      const iconHref = m.style.iconHref;
      if (iconHref){
        const name = registerIconUrl(iconHref); // GL name
        if (name) iconName = name;
        iconUrl = iconHref; // Leaflet directly uses URL
      }

      const isPoint = f.geometry && f.geometry.type === 'Point';
      const enriched = {
        type:'Feature', geometry:f.geometry,
        properties:{
          ...props, name:itemName, fid, hidden:false,
          _label: isPoint ? defaultLabelFrom(itemName) : '',
          _icon: isPoint ? iconName : undefined,   // GL image name
          _iconUrl: isPoint ? iconUrl : undefined, // Leaflet URL
          _iconSize: 1,
          ...style
        }
      };
      features.push(enriched);
      items.push({ fid, name:itemName, visible:true });
    }

    const entry = { id: layerSeq++, name: gname, visible:true,
      data: { type:'FeatureCollection', features }, items,
      glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };

    layerList.push(entry);
    // render on both engines (whichever is visible now or later)
    if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load', ()=> createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
  }

  renderLayers(); renderGroupsVisibility();
}

/* ================= Upload/Drop/URL buttons ================= */
byId('upload-btn').onclick=()=>byId('upload-input').click();
byId('upload-input').addEventListener('change', ev=>{
  const files=[...(ev.target.files||[])];
  (function next(i){
    if(i>=files.length){ ev.target.value=''; return; }
    const f=files[i];
    if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1));
    else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); });
  })(0);
});
byId('dz').addEventListener('dragenter', e=>{ e.preventDefault(); e.currentTarget.classList.add('dragover'); });
byId('dz').addEventListener('dragover',  e=>{ e.preventDefault(); e.currentTarget.classList.add('dragover'); });
byId('dz').addEventListener('dragleave', e=>{ e.preventDefault(); e.currentTarget.classList.remove('dragover'); });
byId('dz').addEventListener('drop', e=>{
  e.preventDefault(); e.currentTarget.classList.remove('dragover');
  const files=[...(e.dataTransfer?.files||[])];
  (function next(i){
    if(i>=files.length) return;
    const f=files[i];
    if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1));
    else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); });
  })(0);
});
byId('url-load').onclick=()=>{
  const url=byId('url-input').value.trim(); if(!url) return;
  (/\.kmz(\?|#|$)/i.test(url) ? loadKMZFromUrl(url) : loadKMLFromUrl(url))
    .catch(e=>{ console.error(e); alert('Failed to load from URL (CORS or bad link).'); });
};

/* Add empty layer button */
byId('add-layer').onclick=function(){
  const entry = { id: layerSeq++, name:'Untitled layer', visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
  layerList.push(entry); createGroupBoth(entry); renderLayers(); renderGroupsVisibility();
};
byId('share').onclick=()=>alert('Sharing is not implemented in this demo.');
byId('preview').onclick=()=>alert('Preview mode would hide the editor UI in a deployed build.');

/* ===== Sidebar minimize / reopen ===== */
const appEl = document.getElementById('app');
const sidebarEl = document.getElementById('sidebar');
const btnHide = document.getElementById('ui-hide');
const btnReopen = document.getElementById('ui-reopen');
function collapseUI(){ appEl.classList.add('ui-collapsed'); document.documentElement.style.setProperty('--side','0px'); }
function expandUI(){ document.documentElement.style.setProperty('--side','380px'); appEl.classList.remove('ui-collapsed'); }
btnHide.addEventListener('click', collapseUI);
btnReopen.addEventListener('click', expandUI);
sidebarEl.addEventListener('transitionend', (e)=>{ if(e.propertyName === 'width'){ if(engine==='gl') mapgl.resize(); else mapleaf.invalidateSize(true); }});

/* ===== Basemap switch (GL styles vs OSM via Leaflet) ===== */
document.getElementById('basemap').addEventListener('change', (e)=>{
  const val = e.target.value;
  if (val === 'osm'){
    showLeaf();
  }else{
    // choose GL style
    if (val === 'custom') mapgl.setStyle(CUSTOM_STYLE);
    else if (val === 'streets') mapgl.setStyle(maptilersdk.MapStyle.STREETS);
    readdAllGroupsAfterGLStyleChange();
    showGL();
  }
});

/* ===== Preload KMZ on open ===== */
const PRELOAD_KMZ_CANDIDATES = [
  'All Coin Records 2023-2024.kmz',
  'All Coins Record 2023-2024.kmz',
  'All Coins Records 2023-2024.kmz'
];
window.addEventListener('DOMContentLoaded', async ()=>{
  for (const name of PRELOAD_KMZ_CANDIDATES){
    try { await loadKMZFromUrl(encodeURI(name)); console.log('Preloaded', name); break; }
    catch(e){ console.warn('Preload failed for', name); }
  }
});
</script>
</body>
</html>
