<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SQKII Mapper — MapTiler + OSM (dark)</title>

  <!-- MapTiler SDK (MapLibre) -->
  <script src="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.umd.min.js"></script>
  <link href="https://cdn.maptiler.com/maptiler-sdk-js/v3.6.1/maptiler-sdk.css" rel="stylesheet" />

  <!-- Leaflet (OSM raster) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- togeojson + jszip -->
  <script src="https://unpkg.com/@tmcw/togeojson@4.7.0/dist/togeojson.umd.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Supabase JS (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.5/dist/umd/supabase.min.js"></script>

  <style>
    :root{
      --panel:#0f1115; --panel-2:#12151b; --muted:#98a2b3; --text:#e5e7eb;
      --accent:#60a5fa; --border:#1f2430; --bg:#0b0d11; --chip:#1c212e; --side:380px;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    .app{position:relative;display:grid;grid-template-columns: var(--side) 1fr;height:100vh;transition:grid-template-columns .28s ease;}
    .ui-reopen{position:absolute;right:10px;top:10px;z-index:1100;display:none;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    .app.ui-collapsed .ui-reopen{display:inline-block;}
    .sidebar{position:relative;background:var(--panel);border-right:1px solid var(--border);overflow:auto;width:var(--side);transition:width .28s ease;}
    .header{padding:12px;border-bottom:1px solid var(--border);}
    .project-title{font-weight:800;font-size:16px;}
    .toolbar{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;}
    .btn{background:var(--chip);border:1px solid var(--border);border-radius:8px;padding:6px 10px;font-weight:600;cursor:pointer;color:var(--text);}
    .btn.small{padding:4px 8px;font-size:12px;}
    .hint{color:var(--muted);font-size:12px;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
    input[type="url"],select{width:100%;box-sizing:border-box;border:1px solid var(--border);border-radius:8px;padding:8px 10px;background:var(--panel-2);color:var(--text);}
    #mapgl, #mapleaf{height:100%;width:100%;}
    .dropzone{border:2px dashed var(--border);border-radius:12px;margin:12px;padding:14px;text-align:center;color:var(--muted);background:var(--panel-2);}
    .dropzone.dragover{border-color:var(--accent);color:var(--accent);background:#0e1729;}
    .layers-empty{padding:14px;}
    .layer{border-bottom:1px solid var(--border);background:var(--panel-2);}
    .layer+.layer{margin-top:10px;border-radius:10px;overflow:hidden;}
    .layer-head{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:10px 12px;}
    .layer-head .title{font-weight:700;}
    .layer-head .note{font-size:12px;color:var(--muted);}
    .layer-head .actions{display:flex;gap:6px;}
    .import-line{padding:8px 12px;background:#0e1420;border-top:1px solid var(--border);}
    .import-line .link{color:var(--accent);font-weight:600;cursor:pointer;}
    .feature{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px 12px;border-top:1px solid var(--border);}
    .feature .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .group-bullet{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;border:1px solid #2a3243;background:#11161f;color:#fff;font-size:12px;font-weight:800;}
    .toggle{display:inline-grid;place-items:center;width:16px;height:16px;border:1px solid #2a3243;border-radius:4px;background:#0f141d;cursor:pointer;}
    .toggle.checked{background:#16a34a;border-color:#16a34a;}
    details.grp{margin:10px 12px;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);}
    details.grp>summary{list-style:none;padding:10px 12px;cursor:pointer;font-weight:700;}
    details.grp>summary::-webkit-details-marker{display:none;}
    .grp-list{padding:8px 12px;display:grid;gap:6px;max-height:220px;overflow:auto;}
    .yt-portrait{width:240px;aspect-ratio:9/16;background:#000;border-radius:12px;overflow:hidden;margin:8px auto;}
    @media (min-width:480px){ .yt-portrait{ width:260px; } }
    .yt-portrait>iframe{width:100%;height:100%;display:block;border:0}
    .ui-hide{position:absolute;top:10px;right:10px;z-index:1001;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-weight:700;cursor:pointer;box-shadow:0 2px 14px rgba(0,0,0,.35);color:var(--text);}
    a{color:var(--accent);}
    .maplibregl-popup-content{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .maplibregl-popup-tip{border-top-color:#0f1115 !important;border-bottom-color:#0f1115 !important;border-left-color:#0f1115 !important;border-right-color:#0f1115 !important;}
    .leaflet-popup-content-wrapper{background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;}
    .leaflet-popup-tip{background:#0f1115;}
    .style-editor{position:fixed;z-index:1200;display:none;min-width:220px;max-width:260px;background:#0f1115;color:#e5e7eb;border:1px solid #1f2430;border-radius:12px;padding:12px;box-shadow:0 12px 32px rgba(0,0,0,.45);}
    .style-editor h4{margin:0 0 8px 0;font-size:14px;}
    .style-row{display:grid;grid-template-columns:auto 1fr;gap:8px;align-items:center;margin:8px 0;}
    .style-row input[type="color"],.style-row input[type="number"],.style-row input[type="range"]{width:100%;background:#12151b;border:1px solid #1f2430;color:#e5e7eb;border-radius:8px;padding:6px 8px;}
    .style-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:6px;}
    .style-actions .btn{padding:6px 10px;}

    /* ---- Server Code Modal ---- */
    .modal{
      position:fixed;inset:0;background:rgba(0,0,0,.5);display:grid;place-items:center;z-index:2000;
    }
    .modal-card{
      background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;max-width:360px;width:92%;
      box-shadow:0 12px 40px rgba(0,0,0,.5);
    }
    .modal-card h3{margin:0 0 8px 0;font-size:16px}
    .modal-row{display:grid;grid-template-columns:1fr auto;gap:8px;margin-top:8px}
    .modal small{color:var(--muted)}
    .modal .err{color:#f87171;font-weight:700;margin-top:6px;display:none}
  </style>
</head>
<body>
<div class="app" id="app">
  <button id="ui-reopen" class="ui-reopen" title="Open UI">Open UI</button>

  <aside class="sidebar" id="sidebar">
    <button id="ui-hide" class="ui-hide" title="Hide UI">Hide UI</button>

    <div class="header">
      <div class="project-title">SQKII MAPPER</div>
      <div class="toolbar">
        <button class="btn small" id="upload-btn">Upload</button>
        <input id="upload-input" type="file" accept=".kml,.kmz" multiple style="display:none" />
        <button class="btn small" id="add-layer">Add layer</button>
        <button class="btn small" id="export-kml">Export KML</button>
        <button class="btn small" id="export-kmz">Export KMZ</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <input id="url-input" type="url" placeholder="https://example.com/map.kml or .kmz" />
        <button class="btn small" id="url-load">Load URL</button>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <div class="hint" style="margin-bottom:4px;">Map style</div>
          <select id="basemap">
            <option value="custom" selected>Custom (your MapTiler style)</option>
            <option value="streets">MapTiler Streets</option>
            <option value="dark">MapTiler Dark</option>
            <option value="outdoor">MapTiler Outdoor</option>
            <option value="satellite">MapTiler Satellite</option>
            <option value="osm">OpenStreetMap (raster)</option>
          </select>
        </div>
        <div></div>
      </div>

      <div class="hint" style="margin-top:6px;">Dark UI · autosaves to your browser · realtime sync via server code</div>
    </div>

    <div class="dropzone" id="dz">
      <div><strong>Drop KML/KMZ here</strong></div>
      <div class="hint">…or use the Upload button above</div>
    </div>

    <details class="grp" id="group-visibility" open>
      <summary>Groups visibility</summary>
      <div class="grp-list" id="grp-list"></div>
    </details>

    <div id="layers"></div>
  </aside>

  <!-- Two engines -->
  <main id="mapgl"></main>
  <main id="mapleaf" style="display:none"></main>

  <!-- Long-press style editor -->
  <div id="style-editor" class="style-editor">
    <h4>Edit shape style</h4>
    <div class="style-row"><label>Fill</label><input id="se-fill" type="color" value="#0b57d0"></div>
    <div class="style-row"><label>Opacity</label><input id="se-fillop" type="range" min="0" max="1" step="0.05" value="0.2"></div>
    <div class="style-row"><label>Outline</label><input id="se-outline" type="checkbox" checked></div>
    <div class="style-row"><label>Stroke</label><input id="se-stroke" type="color" value="#0b57d0"></div>
    <div class="style-row"><label>Width</label><input id="se-width" type="number" min="0" max="20" step="0.5" value="2"></div>
    <div class="style-actions"><button class="btn small" id="se-close">Close</button></div>
  </div>
</div>

<!-- ===== Server Code Modal ===== -->
<div id="server-modal" class="modal" style="display:grid">
  <div class="modal-card">
    <h3>Join a server</h3>
    <small>Enter your shared <strong>Server Code</strong> to sync with others.</small>
    <div class="modal-row">
      <input id="server-code-input" placeholder="e.g. gold-team" />
      <button id="server-code-join" class="btn small">Join</button>
    </div>
    <small>New code? We'll create it automatically.</small>
    <div id="server-error" class="err"></div>
  </div>
</div>

<script>
/* ================= Map engines ================= */
maptilersdk.config.apiKey = 'f9B8Wv0ythtbvpcK0QEw';
const CUSTOM_STYLE = 'https://api.maptiler.com/maps/01994e5b-af91-7fae-b8bd-a68c497abf96/style.json?key=' + maptilersdk.config.apiKey;

const mapgl = new maptilersdk.Map({ container:'mapgl', style:CUSTOM_STYLE, center:[103.8198,1.3521], zoom:12 });
function glReady(fn){ if (mapgl.isStyleLoaded && mapgl.isStyleLoaded()) fn(); else mapgl.once('load', fn); }

const mapleaf = L.map('mapleaf', { zoomControl:true, attributionControl:true }).setView([1.3521,103.8198], 12);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19, attribution:'&copy; OpenStreetMap contributors'}).addTo(mapleaf);

let engine='gl';
function showGL(){ const c=mapleaf.getCenter(), z=mapleaf.getZoom(); document.getElementById('mapleaf').style.display='none'; document.getElementById('mapgl').style.display='block'; mapgl.resize(); mapgl.jumpTo({center:[c.lng,c.lat], zoom:z}); engine='gl'; }
function showLeaf(){ const c=mapgl.getCenter(), z=mapgl.getZoom(); document.getElementById('mapgl').style.display='none'; document.getElementById('mapleaf').style.display='block'; mapleaf.invalidateSize(true); mapleaf.setView([c.lat,c.lng], Math.round(z)); engine='leaf'; }

/* ================= Icon registry ================= */
const DOLLAR_ICON_NAME='dollar-pin'; let iconSeq=1;
const urlToName=new Map(), nameToUrl=new Map();
function dollarSvg(size){const s=size||64; return `<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 32 32"><circle cx="16" cy="16" r="13" fill="#111" stroke="white" stroke-width="1.5"/><text x="16" y="21" text-anchor="middle" font-family="system-ui,Segoe UI,Arial" font-size="16" font-weight="800" fill="white">$</text></svg>`;}
function addImageToGL(name, url){return new Promise(res=>{const img=new Image(); img.crossOrigin='anonymous'; img.referrerPolicy='no-referrer'; img.onload=()=>{try{mapgl.addImage(name,img,{pixelRatio:2});}catch{}res();}; img.onerror=()=>res(); img.src=url;});}
async function ensureDollarIcon(){ if(mapgl.hasImage && mapgl.hasImage(DOLLAR_ICON_NAME)) return; await addImageToGL(DOLLAR_ICON_NAME, 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(64))); }
function registerIconUrl(url){ if(!url) return DOLLAR_ICON_NAME; if(urlToName.has(url)) return urlToName.get(url); const name='icon-'+(iconSeq++); urlToName.set(url,name); nameToUrl.set(name,url); if(mapgl.isStyleLoaded&&mapgl.isStyleLoaded()) addImageToGL(name,url); else mapgl.once('load',()=>addImageToGL(name,url)); return name; }
async function ensureAllIconsOnCurrentStyle(){ await ensureDollarIcon(); for(const [url,name] of urlToName.entries()) if(!mapgl.hasImage(name)) await addImageToGL(name,url); }
mapgl.on('styleimagemissing', e=>{ const url=nameToUrl.get(e.id); if(url) addImageToGL(e.id,url); });

function readdAllGroupsAfterGLStyleChange(){
  let done=false;
  function hydrate(){ if(done) return; done=true; (async()=>{
    await ensureAllIconsOnCurrentStyle();
    layerList.forEach(e=>{ createGroupOnGL(e,true); if(e.visible===false && e.glLayerIds){ e.glLayerIds.forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility','none'); }); }});
    renderLayers(); renderGroupsVisibility();
  })(); }
  mapgl.once('load', hydrate); mapgl.once('idle', hydrate);
}

/* ================= App state / utils ================= */
let layerSeq=1, featureSeq=1;
const layerList=[]; // {id,name,visible,data,items,glSourceId,glLayerIds[],lfGroup,lfLayers:Map}
const byId=id=>document.getElementById(id);

function kmlColorToCss(aabbggrr){ if(!aabbggrr){return{hex:'#0b57d0',opacity:0.2};} let s=aabbggrr.trim(); if(s.length===6) s='ff'+s; return {hex:'#'+s.slice(6,8)+s.slice(4,6)+s.slice(2,4), opacity:parseInt(s.slice(0,2),16)/255}; }
function defaultLabelFrom(n){ if(!n) return '•'; const c=(n.trim()[0]||'•').toUpperCase(); return /[A-Z0-9$]/.test(c)?c:'•'; }
function escapeHtml(s){return (s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));}
function sanitizeHtml(input){ try{ const parser=new DOMParser(); const doc=parser.parseFromString('<div>'+input+'</div>','text/html'); const allowedTags={A:1,B:1,I:1,EM:1,STRONG:1,P:1,BR:1,UL:1,OL:1,LI:1,IMG:1,DIV:1,SPAN:1}; const allowedAttrs={A:['href','title'], IMG:['src','alt','width','height','loading']}; (function clean(n){ for(const el of [...n.childNodes]){ if(el.nodeType===1){ if(!allowedTags[el.tagName]){ while(el.firstChild) n.insertBefore(el.firstChild,el); n.removeChild(el); continue; } for(const a of [...el.attributes]){ const ok=(allowedAttrs[el.tagName]||[]); if(!ok.includes(a.name.toLowerCase())) el.removeAttribute(a.name); } if(el.tagName==='A'){ const href=el.getAttribute('href')||''; el.setAttribute('target','_blank'); el.setAttribute('rel','noopener'); if(/^javascript:/i.test(href)) el.removeAttribute('href'); } if(el.tagName==='IMG'){ el.setAttribute('loading','lazy'); } clean(el); } } })(doc.body); return doc.body.firstChild.innerHTML; }catch(e){ return ''; } }
function findYouTubeId(str){ if(!str) return ''; const m=String(str).match(/(?:youtube\.com\/watch\?[^#\s]*v=|youtu\.be\/|youtube\.com\/embed\/)([A-Za-z0-9_-]{11})/); return m?m[1]:''; }
function buildYouTubeEmbed(id){
  if(!id) return '';
  const src='https://www.youtube-nocookie.com/embed/'+id+'?rel=0&modestbranding=1&playsinline=1';
  return '<div class="yt-portrait" style="text-align:center"><iframe src="'+src+'" title="YouTube" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>';
}
function buildPopupHTMLFromProps(props){
  const name=props.name||'Feature';
  const raw=props.description||'';
  const looksHtml=/<\/?[a-z][\s\S]*>/i.test(raw);
  let safe=looksHtml?sanitizeHtml(raw):escapeHtml(raw).replace(/(https?:\/\/[^\s<]+)/g,'<a href="$1" target="_blank" rel="noopener">$1</a>');
  const tmp=document.createElement('div'); tmp.innerHTML=safe; tmp.querySelectorAll('img').forEach(img=>img.remove()); safe=tmp.innerHTML;
  const id=findYouTubeId(raw)||findYouTubeId(tmp.textContent||'');
  const embed=buildYouTubeEmbed(id);
  return '<div style="min-width:260px;max-width:340px;">'
       + '<div style="font-weight:800;font-size:16px;margin-bottom:6px;text-align:center;">'+escapeHtml(name)+'</div>'
       + (embed || '')
       + (safe ? '<div style="font-size:13px;line-height:1.35;color:#cbd5e1;font-weight:700;">'+safe+'</div>' : '')
       + '</div>';
}
function bboxOfFeature(f){ let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity; (function scan(c){ if(typeof c[0]==='number'){ const [x,y]=c; minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y);} else c.forEach(scan); })(f.geometry.coordinates); return [[minX,minY],[maxX,maxY]]; }
function panPopupIntoViewGL(lngLat,liftPx=180){ const p=mapgl.project(lngLat); p.y-=liftPx; const center=mapgl.unproject(p); mapgl.easeTo({center,duration:350}); }

/* ========== KMZ helpers: PERSISTENT DATA URLS ========== */
function blobToDataUrl(blob){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }
async function buildKmzAssetMap(zip){
  const out={};
  for(const f of Object.values(zip.files)){
    if(!f.dir && /\.(png|jpe?g|gif|svg)$/i.test(f.name)){
      const blob=await f.async('blob');
      out[f.name] = await blobToDataUrl(blob);
    }
  }
  return out;
}
function resolveIconHref(href,opts){
  if(!href) return '';
  if(/^(https?:|data:)/i.test(href)) return href;
  if(opts && opts.assetMap){
    if(opts.assetMap[href]) return opts.assetMap[href];
    const base=href.split(/[\\/]/).pop();
    for(const k of Object.keys(opts.assetMap)){
      if(k===base || k.endsWith('/'+base)) return opts.assetMap[k];
    }
  }
  if(opts && opts.baseUrl){ try{return new URL(href,opts.baseUrl).href;}catch(e){} }
  return href;
}
function extractKmlMeta(xmlDoc,opts){ function t(n,sel){ const el=n.querySelector(sel); return el ? (el.textContent||'').trim():''; } const styleById={},smById={}; xmlDoc.querySelectorAll('Style[id], style[id]').forEach(s=>styleById[s.getAttribute('id')]=s); xmlDoc.querySelectorAll('StyleMap[id], styleMap[id]').forEach(s=>smById[s.getAttribute('id')]=s); function resolveStyleUrl(url){ if(!url) return null; const id=url.replace(/^#/,''); const sm=smById[id]; if(sm){ for(const p of sm.querySelectorAll('Pair')) if((t(p,'key')||'').toLowerCase()==='normal'){ const su=t(p,'styleUrl'); if(su) return resolveStyleUrl(su); } } return styleById[id]||null; } function topFolderName(node){ let cur=node.parentNode,top=''; while(cur&&cur.nodeType===1){ if(/Folder/i.test(cur.tagName)){ const nm=t(cur,'name'); if(nm) top=nm; } cur=cur.parentNode; } return top||'Untitled layer'; } function parseStyle(sEl){ if(!sEl) return {}; const iconHref=t(sEl,'IconStyle Icon href')||t(sEl,'iconStyle icon href'); const lineColor=t(sEl,'LineStyle color')||t(sEl,'lineStyle color'); const lineWidth=t(sEl,'LineStyle width')||t(sEl,'lineStyle width'); const polyColor=t(sEl,'PolyStyle color')||t(sEl,'polyStyle color'); return {iconHref:resolveIconHref(iconHref,opts),lineColor,lineWidth,polyColor}; } const metas=[]; xmlDoc.querySelectorAll('Placemark, placemark').forEach(pm=>{ const sEl=resolveStyleUrl(t(pm,'styleUrl')); metas.push({name:t(pm,'name'), topFolder:topFolderName(pm), style:parseStyle(sEl)}); }); return metas; }

/* ================= MapLibre overlay ================= */
function createGroupOnGL(entry, clearIfExists){
  glReady(async ()=>{
    await ensureAllIconsOnCurrentStyle();

    const srcId='src-'+entry.id, fillId='fill-'+entry.id, lineId='line-'+entry.id, iconId='icon-'+entry.id, lblId='lbl-'+entry.id, polyEdgeId='polyedge-'+entry.id;
    entry.glSourceId=srcId; entry.glLayerIds=[fillId,lineId,polyEdgeId,iconId,lblId];

    if(clearIfExists){
      [lblId,iconId,polyEdgeId,lineId,fillId].forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
      if(mapgl.getSource(srcId)) try{mapgl.removeSource(srcId);}catch{}
    }

    if(mapgl.getSource(srcId)) mapgl.removeSource(srcId);
    mapgl.addSource(srcId,{type:'geojson', promoteId:'fid', data:entry.data});

    const notHidden=['!=',['get','hidden'],true];

    mapgl.addLayer({ id:fillId, type:'fill', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['Polygon','MultiPolygon']]]],
      paint:{ 'fill-color':['coalesce',['get','_fill'],'#0b57d0'], 'fill-opacity':['coalesce',['get','_fillOpacity'],0.2] } });

    mapgl.addLayer({ id:polyEdgeId, type:'line', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['Polygon','MultiPolygon']]]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#0b57d0'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.9] } });

    mapgl.addLayer({ id:lineId, type:'line', source:srcId,
      filter:['all',notHidden,['in',['geometry-type'],['literal',['LineString','MultiLineString']]]],
      paint:{ 'line-color':['coalesce',['get','_stroke'],'#0b57d0'], 'line-width':['coalesce',['get','_weight'],2], 'line-opacity':['coalesce',['get','_strokeOpacity'],0.9] } });

    mapgl.addLayer({ id:iconId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point']],
      layout:{ 'icon-image':['coalesce',['get','_icon'],DOLLAR_ICON_NAME], 'icon-size':['coalesce',['get','_iconSize'],1], 'icon-anchor':'bottom', 'icon-allow-overlap':true } });

    mapgl.addLayer({ id:lblId, type:'symbol', source:srcId,
      filter:['all',notHidden,['==',['geometry-type'],'Point']],
      layout:{ 'text-field':['coalesce',['get','_label'],''], 'text-font':['Noto Sans Regular'], 'text-size':11, 'text-offset':[0,1.1], 'text-anchor':'top' },
      paint:{ 'text-color':'#e5e7eb','text-halo-color':'#0b0d11','text-halo-width':1.2 } });

    const POP=18;
    [fillId,polyEdgeId,lineId,iconId,lblId].forEach(lid=>{
      mapgl.on('click', lid, (e)=>{
        panPopupIntoViewGL(e.lngLat, 180);
        new maptilersdk.Popup({ anchor:'bottom', offset:[0,POP], maxWidth:'340px', closeOnClick:true })
          .setLngLat(e.lngLat).setHTML(buildPopupHTMLFromProps((e.features[0]&&e.features[0].properties)||{})).addTo(mapgl);
      });
    });

    attachLongPressGL(fillId, entry);
    attachLongPressGL(polyEdgeId, entry);
  });
}
function refreshGroupGL(entry){ const src=mapgl.getSource(entry.glSourceId); if(src) src.setData(entry.data); }

/* ================= Leaflet overlay ================= */
function dollarDataUrl(size=32){ return 'data:image/svg+xml;charset=UTF-8,'+encodeURIComponent(dollarSvg(size)); }
function leafletIconFor(url,size=32){ return L.icon({iconUrl:url||dollarDataUrl(size),iconSize:[size,size],iconAnchor:[size/2,size-2],popupAnchor:[0,-size/2]}); }
function createGroupOnLeaflet(entry,rebuild=false){
  if(rebuild && entry.lfGroup){ try{entry.lfGroup.remove();}catch{} }
  entry.lfGroup=L.layerGroup().addTo(mapleaf);
  entry.lfLayers=new Map();

  entry.data.features.forEach(f=>{
    const fid=f.properties.fid, list=[];
    const strokeOn = (f.properties._strokeOpacity ?? 0.9) > 0 && (f.properties._weight ?? 2) > 0;
    const polyStyle={ color:f.properties._stroke||'#0b57d0', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.9, fillColor:f.properties._fill||'#0b57d0', fillOpacity:f.properties._fillOpacity ?? 0.2, stroke: strokeOn };
    const lineStyle={ color:f.properties._stroke||'#0b57d0', weight:f.properties._weight||2, opacity:f.properties._strokeOpacity ?? 0.9 };

    if(f.geometry.type==='Point'){
      const [lng,lat]=f.geometry.coordinates;
      const icon=leafletIconFor(f.properties._iconUrl || nameToUrl.get(f.properties._icon),32);
      const m=L.marker([lat,lng],{icon}).bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) m.addTo(entry.lfGroup); list.push(m);
    }else{
      const gj=L.geoJSON(f,{ style: geom=> (geom.type.includes('Polygon')?polyStyle:lineStyle) })
        .bindPopup(buildPopupHTMLFromProps(f.properties),{autoPan:true,offset:[0,-18]});
      if(!f.properties.hidden) gj.addTo(entry.lfGroup);
      list.push(gj);
      gj.on('mousedown', (ev)=> attachLongPressLeaf(ev, entry, fid));
      gj.on('touchstart', (ev)=> attachLongPressLeaf(ev, entry, fid));
    }
    entry.lfLayers.set(fid, list);
  });
}
function refreshGroupBoth(entry){
  refreshGroupGL(entry);
  if(entry.lfGroup){ try{ entry.lfGroup.clearLayers(); }catch{} createGroupOnLeaflet(entry, true); }
}

/* ================= UI ================= */
function renderGroupsVisibility(){
  const host=byId('grp-list'); host.innerHTML='';
  if(!layerList.length){ host.innerHTML='<div class="hint">No groups yet.</div>'; return; }
  for(const entry of layerList){
    const row=document.createElement('div'); row.className='grp-row';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=entry.visible!==false;
    const name=document.createElement('div'); name.textContent=entry.name;
    const count=document.createElement('div'); count.className='hint'; count.textContent=entry.items.length;
    cb.onchange=()=>{ entry.visible=cb.checked; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',cb.checked?'visible':'none'); }); if(entry.lfGroup){ if(cb.checked) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderLayers(); saveState(); };
    row.append(cb,name,count); host.appendChild(row);
  }
}
function renderLayers(){
  const host=byId('layers'); host.innerHTML='';
  if(!layerList.length){ host.innerHTML='<div class="layers-empty"><div class="hint">No layers yet. Upload or drop a KML/KMZ.</div></div>'; return; }
  for(const entry of layerList){
    const visibleOnMap=entry.visible!==false;
    const wrap=document.createElement('div'); wrap.className='layer';
    const head=document.createElement('div'); head.className='layer-head';
    const vis=document.createElement('div'); vis.className=visibleOnMap?'toggle checked':'toggle'; vis.title='Show/Hide layer';
    vis.onclick=()=>{ entry.visible=!visibleOnMap; (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility',entry.visible?'visible':'none'); }); if(entry.lfGroup){ if(entry.visible) entry.lfGroup.addTo(mapleaf); else mapleaf.removeLayer(entry.lfGroup); } renderGroupsVisibility(); renderLayers(); saveState(); };

    const ttl=document.createElement('div'); ttl.className='title'; ttl.textContent=entry.name;

    const actions=document.createElement('div'); actions.className='actions';
    const renameBtn=document.createElement('button'); renameBtn.className='btn small'; renameBtn.textContent='Rename';
    renameBtn.onclick=()=>{ const nn=prompt('New layer name:', entry.name); if(!nn) return; entry.name=nn; renderGroupsVisibility(); renderLayers(); saveState(); };
    const delBtn=document.createElement('button'); delBtn.className='btn small'; delBtn.textContent='Delete';
    delBtn.onclick=()=>{ if(!confirm('Delete this layer?')) return; (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} }); if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{}; if(entry.lfGroup) try{entry.lfGroup.remove();}catch{}; const ix=layerList.findIndex(l=>l.id===entry.id); if(ix>=0) layerList.splice(ix,1); renderGroupsVisibility(); renderLayers(); saveState(); };
    actions.append(renameBtn, delBtn);

    head.append(vis, ttl, actions); wrap.appendChild(head);

    if(visibleOnMap){
      const importLine=document.createElement('div'); importLine.className='import-line';
      const link=document.createElement('span'); link.className='link'; link.textContent='Import more';
      link.onclick=()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.kml,.kmz'; inp.onchange=ev=>{ const f=ev.target.files[0]; if(!f) return; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f,entry.name); else f.text().then(txt=>addKmlText(txt,f.name,{},entry.name)); }; inp.click(); };
      importLine.appendChild(link); wrap.appendChild(importLine);

      for(const it of entry.items){
        const row=document.createElement('div'); row.className='feature';
        const ico=document.createElement('div'); ico.className='group-bullet'; ico.textContent=it.label || '$';
        const name=document.createElement('div'); name.className='name'; name.textContent=it.name; name.onclick=()=> zoomToFeature(entry,it.fid);
        const togg=document.createElement('div'); togg.className=it.visible!==false?'toggle checked':'toggle';
        togg.onclick=()=>{ it.visible=!(it.visible!==false); const gf=entry.data.features.find(f=>f.properties.fid===it.fid); if(gf){ gf.properties.hidden = it.visible===false; refreshGroupBoth(entry); } togg.className=it.visible!==false?'toggle checked':'toggle'; saveState(); };
        row.append(ico,name,togg); wrap.appendChild(row);
      }
    }
    host.appendChild(wrap);
  }
}
function zoomToFeature(entry,fid){ const f=entry.data.features.find(x=>x.properties&&x.properties.fid===fid); if(!f) return; const b=bboxOfFeature(f); if(engine==='gl') mapgl.fitBounds(b,{padding:40,duration:600}); else mapleaf.fitBounds([[b[0][1],b[0][0]],[b[1][1],b[1][0]]],{padding:[40,40]}); }

/* ================= Loaders ================= */
async function loadKMZFile(file,forceGroupName){ try{ const zip=await JSZip.loadAsync(file); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry){ alert('No .kml found inside KMZ: '+file.name); return; } const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,file.name,{assetMap},forceGroupName); }catch(e){ console.error(e); alert('Failed to read KMZ: '+file.name); } }
async function loadKMLFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const text=await res.text(); addKmlText(text,url.split('/').pop()||'remote.kml',{baseUrl:url},forceGroupName); }
async function loadKMZFromUrl(url,forceGroupName){ const res=await fetch(url); if(!res.ok) throw new Error('HTTP '+res.status); const blob=await res.blob(); const zip=await JSZip.loadAsync(blob); const kmlEntry=Object.values(zip.files).find(f=>f.name.toLowerCase().endsWith('.kml')); if(!kmlEntry) throw new Error('No .kml inside KMZ'); const assetMap=await buildKmzAssetMap(zip); const text=await kmlEntry.async('text'); addKmlText(text,url.split('/').pop()||'remote.kmz',{assetMap,baseUrl:url},forceGroupName); }

function addKmlText(text,filename,opts,forceGroupName){
  const xml=new DOMParser().parseFromString(text,'text/xml');
  const metaList=extractKmlMeta(xml,opts||{});
  const gj=window.toGeoJSON.kml(xml);
  if(!gj || !gj.features || !gj.features.length){ alert('No features in '+filename); return; }

  const grouped={}; metaList.forEach((m,i)=>{ const f=forceGroupName||m.topFolder||'Untitled layer'; (grouped[f]||(grouped[f]=[])).push(i); });

  for(const gname of Object.keys(grouped)){
    const features=[], items=[];
    for(const idx of grouped[gname]){
      const f=gj.features[idx], m=metaList[idx], fid=featureSeq++;
      const props=f.properties||{}; const itemName=m.name||props.name||props.Name||props.title||('Feature '+fid);

      const style={};
      if(m.style.lineColor){ const lc=kmlColorToCss(m.style.lineColor); style._stroke=lc.hex; style._strokeOpacity=lc.opacity; }
      if(m.style.lineWidth){ const w=parseFloat(m.style.lineWidth); if(!isNaN(w)) style._weight=w; }
      if(m.style.polyColor){ const pc=kmlColorToCss(m.style.polyColor); style._fill=pc.hex; style._fillOpacity=pc.opacity; }
      if(style._fillOpacity===undefined) style._fillOpacity=0.2;
      if(style._stroke===undefined) style._stroke='#0b57d0';
      if(style._weight===undefined) style._weight=2;
      if(style._strokeOpacity===undefined) style._strokeOpacity=0.9;

      let iconName=DOLLAR_ICON_NAME, iconUrl='';
      const iconHref=m.style.iconHref;
      if(iconHref){ const name=registerIconUrl(iconHref); if(name) iconName=name; iconUrl=iconHref; }

      const isPoint=f.geometry && f.geometry.type==='Point';
      const label = isPoint ? defaultLabelFrom(itemName) : '•';

      const enriched={ type:'Feature', geometry:f.geometry,
        properties:{ ...props, name:itemName, fid, hidden:false, _label:isPoint?label:'', _icon:isPoint?iconName:undefined, _iconUrl:isPoint?iconUrl:undefined, _iconSize:1, ...style } };
      features.push(enriched); items.push({fid,name:itemName,label,visible:true});
    }

    const entry={ id:layerSeq++, name:gname, visible:true, data:{type:'FeatureCollection',features}, items, glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
  }

  renderLayers(); renderGroupsVisibility(); saveState();
}

/* ========= Upload/Drop/URL ========= */
byId('upload-btn').onclick=()=>byId('upload-input').click();
byId('upload-input').addEventListener('change', ev=>{
  const files=[...(ev.target.files||[])];
  (function next(i){ if(i>=files.length){ ev.target.value=''; return; }
    const f=files[i];
    if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1));
    else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); });
  })(0);
});
['dragenter','dragover','dragleave','drop'].forEach(evt=>{
  byId('dz').addEventListener(evt, e=>{
    e.preventDefault(); if(evt==='dragenter'||evt==='dragover') e.currentTarget.classList.add('dragover'); else if(evt==='dragleave') e.currentTarget.classList.remove('dragover');
    if(evt==='drop'){ e.currentTarget.classList.remove('dragover'); const files=[...(e.dataTransfer?.files||[])]; (function next(i){ if(i>=files.length) return; const f=files[i]; if(f.name.toLowerCase().endsWith('.kmz')) loadKMZFile(f).then(()=>next(i+1)); else f.text().then(txt=>{ addKmlText(txt,f.name); next(i+1); }); })(0); }
  });
});
byId('url-load').onclick=()=>{ const url=byId('url-input').value.trim(); if(!url) return; (/\.kmz(\?|#|$)/i.test(url) ? loadKMZFromUrl(url) : loadKMLFromUrl(url)).catch(e=>{ console.error(e); alert('Failed to load from URL (CORS or bad link).'); }); };

/* Add empty layer */
byId('add-layer').onclick=function(){ const entry={ id:layerSeq++, name:'Untitled layer', visible:true, data:{type:'FeatureCollection',features:[]}, items:[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null }; layerList.push(entry); createGroupOnGL(entry); createGroupOnLeaflet(entry); renderLayers(); renderGroupsVisibility(); saveState(); };

/* ===== Sidebar minimize / reopen ===== */
const appEl=document.getElementById('app'), sidebarEl=document.getElementById('sidebar'), btnHide=document.getElementById('ui-hide'), btnReopen=document.getElementById('ui-reopen');
function collapseUI(){ appEl.classList.add('ui-collapsed'); document.documentElement.style.setProperty('--side','0px'); }
function expandUI(){ document.documentElement.style.setProperty('--side','380px'); appEl.classList.remove('ui-collapsed'); }
btnHide.addEventListener('click',collapseUI); btnReopen.addEventListener('click',expandUI);
sidebarEl.addEventListener('transitionend',e=>{ if(e.propertyName==='width'){ if(engine==='gl') mapgl.resize(); else mapleaf.invalidateSize(true); }});

/* ===== Basemap switching ===== */
document.getElementById('basemap').addEventListener('change', (e)=>{
  const val=e.target.value;
  if(val==='osm'){ showLeaf(); }
  else {
    if(val==='custom') mapgl.setStyle(CUSTOM_STYLE);
    else if(val==='streets') mapgl.setStyle(maptilersdk.MapStyle.STREETS);
    else if(val==='dark') mapgl.setStyle(maptilersdk.MapStyle.DARK);
    else if(val==='outdoor') mapgl.setStyle(maptilersdk.MapStyle.OUTDOOR);
    else if(val==='satellite') mapgl.setStyle(maptilersdk.MapStyle.SATELLITE);
    readdAllGroupsAfterGLStyleChange(); showGL();
  }
  closeStyleEditor();
});

/* ===== Preload sequence + Restore ===== */
const PRELOAD_GEOHASHES = 'geohashesGold.kmz';
const PRELOAD_COINS = ['All Coin Records 2023-2024.kmz','All Coins Record 2023-2024.kmz','All Coins Records 2023-2024.kmz'];

/* ===== Long-press style editor ===== */
const editorEl=byId('style-editor');
const seFill=byId('se-fill'), seFillOp=byId('se-fillop'), seOutline=byId('se-outline'), seStroke=byId('se-stroke'), seWidth=byId('se-width'), seClose=byId('se-close');
let editCtx=null;
function openStyleEditor(entry,fid,screenX,screenY){
  editCtx={entry,fid};
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  seFill.value = p._fill || '#0b57d0';
  seFillOp.value = (p._fillOpacity ?? 0.2);
  const strokeOn = (p._strokeOpacity ?? 0.9) > 0 && (p._weight ?? 2) > 0;
  seOutline.checked = strokeOn;
  seStroke.value = p._stroke || '#0b57d0';
  seWidth.value = p._weight ?? 2;
  editorEl.style.left = Math.min(screenX+10, window.innerWidth-280)+'px';
  editorEl.style.top  = Math.min(screenY+10, window.innerHeight-220)+'px';
  editorEl.style.display='block';
}
function closeStyleEditor(){ editorEl.style.display='none'; editCtx=null; }
function applyEditor(){
  if(!editCtx) return;
  const {entry,fid}=editCtx;
  const f=entry.data.features.find(x=>x.properties.fid===fid); if(!f) return;
  const p=f.properties;
  p._fill = seFill.value;
  p._fillOpacity = parseFloat(seFillOp.value);
  if(seOutline.checked){ p._stroke = seStroke.value; p._weight = parseFloat(seWidth.value)||0; p._strokeOpacity = 0.9; }
  else { p._strokeOpacity = 0.0; p._weight = 0; }
  refreshGroupBoth(entry); saveState();
}
[seFill,seFillOp,seOutline,seStroke,seWidth].forEach(inp=> inp.addEventListener('input', applyEditor));
seClose.addEventListener('click', closeStyleEditor);

function attachLongPressGL(layerId, entry){
  let t=null;
  function clear(){ if(t){ clearTimeout(t); t=null; } }
  function start(e){
    const feat=e.features && e.features[0]; if(!feat) return;
    const type=feat.geometry && feat.geometry.type;
    if(type!=='Polygon' && type!=='MultiPolygon') return;
    const fid=feat.properties && feat.properties.fid;
    const pt=e.point||{x:0,y:0};
    t=setTimeout(()=>{ openStyleEditor(entry,fid, pt.x, pt.y); }, 500);
  }
  ['mousedown','touchstart'].forEach(ev=> mapgl.on(ev, layerId, start));
  ['mouseup','mouseleave','drag','move','touchend','touchcancel'].forEach(ev=> mapgl.on(ev, clear));
}
function attachLongPressLeaf(ev, entry, fid){
  let timer=null;
  function cancel(){ if(timer){ clearTimeout(timer); timer=null; } }
  timer=setTimeout(()=>{ const p=ev.originalEvent && ev.originalEvent.touches && ev.originalEvent.touches[0] ? ev.originalEvent.touches[0] : ev.originalEvent; openStyleEditor(entry,fid, p.clientX, p.clientY); }, 500);
  document.addEventListener('mouseup', ()=>cancel(), {once:true});
  document.addEventListener('touchend', ()=>cancel(), {once:true});
}
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeStyleEditor(); });

/* ================= Autosave / Restore (local) ================= */
const LS_KEY='sqkii-mapper-state-v1';
function shallowSerializableState(){ return layerList.map(l=>({ id:l.id, name:l.name, visible:l.visible!==false, data:l.data, items:l.items })); }
/* IMPORTANT: saveState is overridden below to also sync to Supabase */
function localSaveOnly(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(shallowSerializableState())); }catch(e){ console.warn('Autosave failed',e); } }
window.addEventListener('beforeunload', localSaveOnly);

/* Helper to ensure feature icons after loading external state */
async function rebindFeatureIcons(entry){
  for (const f of (entry.data?.features || [])) {
    const p = f.properties || {};
    if (p._iconUrl) {
      const id = registerIconUrl(p._iconUrl);
      if (id) p._icon = id;
    } else if (p._icon == null) {
      p._icon = DOLLAR_ICON_NAME;
    }
  }
}

/* Wipe all current layers and maps before applying remote state */
function clearAllLayers(){
  for(const entry of [...layerList]){
    (entry.glLayerIds||[]).forEach(id=>{ if(mapgl.getLayer(id)) try{mapgl.removeLayer(id);}catch{} });
    if(entry.glSourceId && mapgl.getSource(entry.glSourceId)) try{mapgl.removeSource(entry.glSourceId);}catch{};
    if(entry.lfGroup) try{entry.lfGroup.remove();}catch{};
  }
  layerList.length = 0;
  renderGroupsVisibility(); renderLayers();
}

/* Apply a full saved state array -> into live app */
async function applyStateArray(arr){
  clearAllLayers();
  await ensureAllIconsOnCurrentStyle();
  for (const saved of (arr||[])){
    const entry={ id:saved.id ?? layerSeq++, name:saved.name ?? 'Layer', visible:saved.visible!==false, data:saved.data, items:saved.items||[], glSourceId:null, glLayerIds:[], lfGroup:null, lfLayers:null };
    await rebindFeatureIcons(entry);
    layerList.push(entry);
    if(mapgl.isStyleLoaded && mapgl.isStyleLoaded()) createGroupOnGL(entry); else mapgl.once('load',()=>createGroupOnGL(entry));
    createGroupOnLeaflet(entry);
    if(entry.visible === false){
      (entry.glLayerIds||[]).forEach(lid=>{ if(mapgl.getLayer(lid)) mapgl.setLayoutProperty(lid,'visibility','none'); });
      if(entry.lfGroup) mapleaf.removeLayer(entry.lfGroup);
    }
  }
  layerSeq = Math.max( (layerList.map(l=>l.id).concat(0)) ) + 1;
  featureSeq = Math.max( ...layerList.flatMap(l => (l.data?.features||[]).map(f => f.properties?.fid || 0)), 0) + 1;
  renderGroupsVisibility(); renderLayers();
}

/* =======================
   === SUPABASE INTEGRATION ===
   ======================= */
const SUPABASE_URL = 'https://kikgckmpncqdxqxzqlsf.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtpa2dja21wbmNxZHhxeHpxbHNmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzgxNDUsImV4cCI6MjA3MzYxNDE0NX0.VE1mTKPlRKY3LlYQuUdE_ksz7bSb8Sk38lIPj1elbmc';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let currentRoomCode = null;
const clientId = (()=>crypto.getRandomValues(new Uint32Array(4)).join('-'))();

function debounce(fn, ms){ let t=null; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

async function fetchRoom(code){
  const { data, error } = await supabase.from('rooms').select('*').eq('code', code).maybeSingle();
  if(error) throw error;
  return data;
}

async function upsertRoomState(code, state){
  const { error } = await supabase.from('rooms').upsert({
    code,
    state,
    updated_by: clientId,
    updated_at: new Date().toISOString()
  }, { onConflict:'code' });
  if(error) throw error;
}

let suppressNextRemoteApply = false; // guard for local->remote echo

const syncToServerDebounced = debounce(async function(){
  if(!currentRoomCode) return;
  const state = shallowSerializableState();
  try{
    suppressNextRemoteApply = true; // we expect to hear our own update back
    await upsertRoomState(currentRoomCode, state);
    localSaveOnly(); // still keep local cache up to date
  }catch(e){
    console.warn('Supabase sync failed:', e);
  }finally{
    setTimeout(()=>{ suppressNextRemoteApply=false; }, 250);
  }
}, 350);

/* Override saveState to also push to server */
function saveState(){ syncToServerDebounced(); }

/* Subscribe to realtime updates for the active room */
let roomChannel = null;
function subscribeRoom(code){
  if(roomChannel){ roomChannel.unsubscribe(); roomChannel=null; }
  roomChannel = supabase.channel('rooms-'+code)
    .on('postgres_changes',
      { event: '*', schema: 'public', table: 'rooms', filter: 'code=eq.'+code },
      async payload=>{
        if(payload.eventType !== 'UPDATE' && payload.eventType !== 'INSERT') return;
        const row = payload.new || payload.record;
        if(!row) return;
        if(row.updated_by === clientId) return; // ignore our own write
        if(suppressNextRemoteApply) return;     // debounced echo guard
        try{
          await applyStateArray(row.state || []);
          localSaveOnly();
        }catch(e){
          console.error('Apply remote state failed', e);
        }
      }
    )
    .subscribe((status)=>{ /* optional: console.log('Realtime', status); */ });
}

/* Join/create a room, load state or seed with preload */
async function joinRoom(code){
  currentRoomCode = code;
  try{
    const existing = await fetchRoom(code);
    if(existing && existing.state && existing.state.length){
      await applyStateArray(existing.state);
    }else{
      // seed: your original preload flow
      clearAllLayers();
      let seeded=false;
      try { await loadKMZFromUrl(encodeURI(PRELOAD_GEOHASHES), 'Geohashes'); seeded=true; } catch(e){ console.warn('Preload geohashes failed', e); }
      if(!seeded){
        // still allow joining even if preload assets unavailable
      }
      for (const name of PRELOAD_COINS){
        try { await loadKMZFromUrl(encodeURI(name)); console.log('Preloaded', name); break; }
        catch(e){ console.warn('Preload failed for', name); }
      }
      await upsertRoomState(code, shallowSerializableState());
    }
    subscribeRoom(code);
  }catch(e){
    console.error('Join failed', e);
    throw e;
  }
}

/* ===== Server Code Modal handlers ===== */
const modal = document.getElementById('server-modal');
const serverInput = document.getElementById('server-code-input');
const serverJoin = document.getElementById('server-code-join');
const serverErr = document.getElementById('server-error');

serverJoin.addEventListener('click', async ()=>{
  const code = (serverInput.value||'').trim();
  if(!code){ serverErr.textContent='Please enter a server code.'; serverErr.style.display='block'; return; }
  serverErr.style.display='none';
  serverJoin.disabled=true; serverJoin.textContent='Joining...';
  try{
    await joinRoom(code);
    modal.style.display='none';
  }catch(e){
    serverErr.textContent='Could not join. Check your connection and try again.';
    serverErr.style.display='block';
  }finally{
    serverJoin.disabled=false; serverJoin.textContent='Join';
  }
});

/* Allow Enter key */
serverInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') serverJoin.click(); });

/* ================= Startup ================= */
window.addEventListener('DOMContentLoaded', async ()=>{
  // Wait for user to choose a server code (no local restore here).
  // Users can still export/import without a room, but we require a code to sync.
  // Optional: prefill from URL ?server=abc
  const urlParams = new URLSearchParams(location.search);
  const preCode = urlParams.get('server') || '';
  if(preCode){ serverInput.value = preCode; }
});
/* ================= Export KML / KMZ ================= */
function escapeXml(s){return String(s).replace(/[<>&'"]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;' }[c]));}
function kmlColorFromCss(hex,opacity){ const h=(hex||'#0b57d0').replace('#',''); const r=parseInt(h.slice(0,2),16)||0, g=parseInt(h.slice(2,4),16)||0, b=parseInt(h.slice(4,6),16)||0; const a=Math.round((opacity==null?1:opacity)*255); const to2=x=>x.toString(16).padStart(2,'0'); return to2(a)+to2(b)+to2(g)+to2(r); }
function serializePlacemark(f){
  const p=f.properties||{}, name=escapeXml(p.name||'Feature'), styleId='s'+(p.fid||'x');
  let geomStr='';
  if(f.geometry.type==='Point'){ const [lng,lat]=f.geometry.coordinates; geomStr=`<Point><coordinates>${lng},${lat},0</coordinates></Point>`; }
  else if(f.geometry.type==='LineString'){ geomStr=`<LineString><coordinates>${f.geometry.coordinates.map(c=>c.join(',')).join(' ')}</coordinates></LineString>`; }
  else if(f.geometry.type==='Polygon'){
    const rings=f.geometry.coordinates.map((ring,i)=>`<${i===0?'outerBoundaryIs':'innerBoundaryIs'}><LinearRing><coordinates>${ring.map(c=>c.join(',')).join(' ')}</coordinates></LinearRing></${i===0?'outerBoundaryIs':'innerBoundaryIs'}>`).join('');
    geomStr=`<Polygon>${rings}</Polygon>`;
  } else return '';
  const style = `
    <Style id="${styleId}">
      <IconStyle>${p._iconUrl?`<Icon><href>${escapeXml(p._iconUrl)}</href></Icon>`:''}</IconStyle>
      <LineStyle><color>${kmlColorFromCss(p._stroke, p._strokeOpacity)}</color><width>${p._weight||2}</width></LineStyle>
      <PolyStyle><color>${kmlColorFromCss(p._fill, p._fillOpacity)}</color></PolyStyle>
    </Style>`;
  return style + `<Placemark><name>${name}</name><styleUrl>#${styleId}</styleUrl>${geomStr}${p.description?`<description><![CDATA[${p.description}]]></description>`:''}</Placemark>`;
}
function exportKMLString(){ const body=layerList.map(l=>`<Folder><name>${escapeXml(l.name)}</name>${l.data.features.filter(f=>!f.properties.hidden).map(serializePlacemark).join('')}</Folder>`).join(''); return `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document>${body}</Document></kml>`; }
function downloadBlob(name, blob){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1500); }
byId('export-kml').onclick=()=>{ const kml=exportKMLString(); downloadBlob('sqkii-export.kml', new Blob([kml],{type:'application/vnd.google-earth.kml+xml'})); };
byId('export-kmz').onclick=async()=>{ const zip=new JSZip(); const kml=exportKMLString(); zip.file('doc.kml', kml); const blob=await zip.generateAsync({type:'blob'}); downloadBlob('sqkii-export.kmz', blob); };
</script>
</body>
</html>
